from rest_framework import serializers
from decimal import Decimal
from django.core.exceptions import ValidationError
from .models import (
    Account, Transaction, KYCApplication, LoanApplication, Loan,
    LoanRepayment, InterestAccrual, FeeStructure, FeeTransaction
)
from banking_backend.utils.sanitizer import Sanitizer
from banking_backend.utils.masking import mask_account_number, mask_email


class AccountSerializer(serializers.ModelSerializer):
    owner_email = serializers.SerializerMethodField()
    decrypted_account_number = serializers.SerializerMethodField()

    class Meta:
        model = Account
        fields = ['id', 'owner', 'owner_email', 'account_number', 'decrypted_account_number', 'type', 'balance', 'status']
        read_only_fields = ['id', 'balance', 'decrypted_account_number']

    def get_decrypted_account_number(self, obj):
        """Return decrypted account number for display."""
        return mask_account_number(obj.get_decrypted_account_number())

    def get_owner_email(self, obj):
        """Return masked owner email."""
        return mask_email(obj.owner.email)

    def validate_account_number(self, value):
        """Validate account number format."""
        return Sanitizer.validate_account_number(value)

    def validate_balance(self, value):
        """Validate balance is not negative."""
        if value < 0:
            raise serializers.ValidationError("Balance cannot be negative.")
        return value


class TransactionSerializer(serializers.ModelSerializer):
    account_number = serializers.SerializerMethodField()
    cashier_email = serializers.SerializerMethodField()
    related_account_number = serializers.SerializerMethodField()

    def get_account_number(self, obj):
        return mask_account_number(obj.account.get_decrypted_account_number())

    def get_cashier_email(self, obj):
        return mask_email(obj.cashier.email)

    def get_related_account_number(self, obj):
        if obj.related_account:
            return mask_account_number(obj.related_account.get_decrypted_account_number())
        return None

    class Meta:
        model = Transaction
        fields = [
            'id', 'account', 'account_number', 'type', 'amount', 'timestamp',
            'cashier', 'cashier_email', 'related_account', 'related_account_number', 'description'
        ]
        read_only_fields = ['id', 'timestamp']

    def validate_amount(self, value):
        """Validate transaction amount - should always be positive."""
        # Convert to absolute value to ensure consistency
        abs_value = abs(value)
        if abs_value <= 0:
            raise serializers.ValidationError("Transaction amount must be positive.")
        if abs_value > Decimal('1000000.00'):  # Max transaction limit
            raise serializers.ValidationError("Transaction amount exceeds maximum limit.")
        return abs_value  # Always return positive value

    def validate_type(self, value):
        """Validate transaction type."""
        valid_types = [choice[0] for choice in Transaction.TRANSACTION_TYPES]
        if value not in valid_types:
            raise serializers.ValidationError(f"Invalid transaction type. Must be one of: {', '.join(valid_types)}")
        return value

    def validate_description(self, value):
        """Validate and sanitize description."""
        return Sanitizer.validate_and_sanitize_description(value, max_length=500)


class KYCApplicationSerializer(serializers.ModelSerializer):
    submitted_by_email = serializers.CharField(source='submitted_by.email', read_only=True)

    class Meta:
        model = KYCApplication
        fields = ['id', 'applicant_name', 'status', 'documents', 'geotag', 'submitted_by', 'submitted_by_email']
        read_only_fields = ['id', 'status']


class LoanApplicationSerializer(serializers.ModelSerializer):
    applicant_email = serializers.SerializerMethodField()
    reviewed_by_email = serializers.SerializerMethodField()

    def get_applicant_email(self, obj):
        return mask_email(obj.applicant.email)

    def get_reviewed_by_email(self, obj):
        if obj.reviewed_by:
            return mask_email(obj.reviewed_by.email)
        return None

    class Meta:
        model = LoanApplication
        fields = [
            'id', 'applicant', 'applicant_email', 'amount_requested', 'term_months',
            'interest_rate', 'purpose', 'status', 'submitted_at', 'reviewed_by',
            'reviewed_by_email', 'reviewed_at', 'approval_notes'
        ]
        read_only_fields = ['id', 'submitted_at', 'reviewed_at', 'reviewed_by', 'approval_notes']

    def validate_amount_requested(self, value):
        """Validate loan amount."""
        if value <= 0:
            raise serializers.ValidationError("Loan amount must be positive.")
        if value > Decimal('500000.00'):  # Max loan amount
            raise serializers.ValidationError("Loan amount exceeds maximum limit.")
        return value

    def validate_term_months(self, value):
        """Validate loan term."""
        if value < 1 or value > 360:  # 1 month to 30 years
            raise serializers.ValidationError("Loan term must be between 1 and 360 months.")
        return value

    def validate_interest_rate(self, value):
        """Validate interest rate."""
        if value < 0 or value > 50:  # 0% to 50%
            raise serializers.ValidationError("Interest rate must be between 0% and 50%.")
        return value

    def validate_purpose(self, value):
        """Validate and sanitize loan purpose description."""
        return Sanitizer.validate_and_sanitize_description(value, max_length=1000)


class LoanSerializer(serializers.ModelSerializer):
    application_details = LoanApplicationSerializer(source='application', read_only=True)
    account_number = serializers.CharField(source='account.account_number', read_only=True)
    monthly_payment = serializers.SerializerMethodField()

    class Meta:
        model = Loan
        fields = [
            'id', 'application', 'application_details', 'account', 'account_number',
            'principal_amount', 'interest_rate', 'term_months', 'disbursement_date',
            'maturity_date', 'status', 'outstanding_balance', 'total_paid', 'monthly_payment'
        ]
        read_only_fields = ['id', 'outstanding_balance', 'total_paid']

    def get_monthly_payment(self, obj):
        return obj.calculate_monthly_payment()


class LoanRepaymentSerializer(serializers.ModelSerializer):
    loan_details = LoanSerializer(source='loan', read_only=True)

    class Meta:
        model = LoanRepayment
        fields = [
            'id', 'loan', 'loan_details', 'amount', 'principal_paid', 'interest_paid',
            'payment_date', 'transaction'
        ]
        read_only_fields = ['id', 'principal_paid', 'interest_paid']

    def validate_amount(self, value):
        """Validate repayment amount."""
        if value <= 0:
            raise serializers.ValidationError("Repayment amount must be positive.")
        return value


class InterestAccrualSerializer(serializers.ModelSerializer):
    loan_details = LoanSerializer(source='loan', read_only=True)

    class Meta:
        model = InterestAccrual
        fields = ['id', 'loan', 'loan_details', 'accrual_date', 'amount_accrued', 'balance_at_accrual']
        read_only_fields = ['id']


class FeeStructureSerializer(serializers.ModelSerializer):
    class Meta:
        model = FeeStructure
        fields = [
            'id', 'name', 'description', 'transaction_type', 'fee_type', 'fixed_amount',
            'percentage', 'min_fee', 'max_fee', 'is_active'
        ]

    def validate_name(self, value):
        """Validate and sanitize fee structure name."""
        return Sanitizer.validate_and_sanitize_name(value, max_length=100)

    def validate_percentage(self, value):
        """Validate percentage value."""
        if value is not None and (value < 0 or value > 100):
            raise serializers.ValidationError("Percentage must be between 0 and 100.")
        return value

    def validate_fixed_amount(self, value):
        """Validate fixed amount."""
        if value is not None and value < 0:
            raise serializers.ValidationError("Fixed amount cannot be negative.")
        return value

    def validate_min_fee(self, value):
        """Validate minimum fee."""
        if value is not None and value < 0:
            raise serializers.ValidationError("Minimum fee cannot be negative.")
        return value

    def validate_max_fee(self, value):
        """Validate maximum fee."""
        if value is not None and value < 0:
            raise serializers.ValidationError("Maximum fee cannot be negative.")
        return value

    def validate(self, data):
        """Cross-field validation."""
        fee_type = data.get('fee_type')
        fixed_amount = data.get('fixed_amount')
        percentage = data.get('percentage')
        min_fee = data.get('min_fee')
        max_fee = data.get('max_fee')

        if fee_type == 'fixed' and fixed_amount is None:
            raise serializers.ValidationError("Fixed amount is required for fixed fee type.")

        if fee_type == 'percentage' and percentage is None:
            raise serializers.ValidationError("Percentage is required for percentage fee type.")

        if min_fee is not None and max_fee is not None and min_fee > max_fee:
            raise serializers.ValidationError("Minimum fee cannot be greater than maximum fee.")

        return data


class FeeTransactionSerializer(serializers.ModelSerializer):
    fee_structure_details = FeeStructureSerializer(source='fee_structure', read_only=True)
    transaction_details = TransactionSerializer(source='transaction', read_only=True)

    class Meta:
        model = FeeTransaction
        fields = ['id', 'transaction', 'transaction_details', 'fee_structure', 'fee_structure_details', 'amount', 'charged_at']
        read_only_fields = ['id', 'charged_at']


class AccountListSerializer(serializers.ModelSerializer):
    """
    Frontend-specific serializer for account list endpoints.
    Maps 'type' to 'name' and only includes fields needed by frontend.
    """
    name = serializers.CharField(source='type', read_only=True)
    
    class Meta:
        model = Account
        fields = ['id', 'name', 'balance']
        read_only_fields = ['id', 'name', 'balance']
    
    def to_representation(self, instance):
        """Custom representation to ensure proper data format for frontend"""
        representation = super().to_representation(instance)
        
        # Ensure balance is a proper number (not Decimal) for frontend compatibility
        representation['balance'] = float(representation['balance'])
        
        return representation


class TransactionListSerializer(serializers.ModelSerializer):
    """
    Frontend-specific serializer for transaction list endpoints.
    Maps 'timestamp' to 'date' with YYYY-MM-DD formatting and includes only needed fields.
    """
    date = serializers.SerializerMethodField()
    
    class Meta:
        model = Transaction
        fields = ['id', 'date', 'description', 'amount']
        read_only_fields = ['id', 'date', 'description', 'amount']
    
    def get_date(self, obj):
        """
        Convert timestamp to YYYY-MM-DD format for frontend compatibility.
        """
        if obj.timestamp:
            return obj.timestamp.strftime('%Y-%m-%d')
        return None
    
    def to_representation(self, instance):
        """Custom representation to ensure proper data format for frontend"""
        representation = super().to_representation(instance)
        
        # Ensure amount is a proper number (not Decimal) for frontend compatibility
        representation['amount'] = float(representation['amount'])
        
        return representation


class FrontendAccountSummarySerializer(serializers.Serializer):
    """
    Frontend-specific serializer for account summary data.
    Handles decimal precision and proper numeric formatting.
    """
    total_savings = serializers.DecimalField(max_digits=15, decimal_places=2)
    total_loans = serializers.DecimalField(max_digits=15, decimal_places=2)
    available_balance = serializers.DecimalField(max_digits=15, decimal_places=2)
    monthly_contributions = serializers.DecimalField(max_digits=15, decimal_places=2)
    account_count = serializers.IntegerField()
    loan_count = serializers.IntegerField()
    
    def to_representation(self, instance):
        """Ensure all numeric fields are properly formatted for frontend"""
        representation = super().to_representation(instance)
        
        # Convert all decimal fields to float for frontend compatibility
        decimal_fields = ['total_savings', 'total_loans', 'available_balance', 'monthly_contributions']
        for field in decimal_fields:
            if field in representation and representation[field] is not None:
                representation[field] = float(representation[field])
        
        return representation


class AccountSummarySerializer(serializers.Serializer):
    """Serializer for account summary data"""
    total_savings = serializers.DecimalField(max_digits=15, decimal_places=2)
    total_loans = serializers.DecimalField(max_digits=15, decimal_places=2)
    available_balance = serializers.DecimalField(max_digits=15, decimal_places=2)
    monthly_contributions = serializers.DecimalField(max_digits=15, decimal_places=2)
    account_count = serializers.IntegerField()
    loan_count = serializers.IntegerField()