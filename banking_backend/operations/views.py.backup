from rest_framework import viewsets, status
from rest_framework.decorators import action, api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.shortcuts import get_object_or_404
from django.db.models import Sum, Count, Q
from django.db import models
from django.utils import timezone
from datetime import timedelta, date
from decimal import Decimal
from .models import Workflow, WorkflowStep, ClientKYC, FieldCollection, Commission, Expense, VisitSchedule, Message
from .serializers import WorkflowSerializer, WorkflowStepSerializer, ClientKYCSerializer, FieldCollectionSerializer, CommissionSerializer, ExpenseSerializer, VisitScheduleSerializer, MessageSerializer
from .permissions import IsOperationsManager, IsMobileBanker, CanReviewKYC, CanManageWorkflows
from users.models import User


class WorkflowViewSet(viewsets.ModelViewSet):
    """
    Handles workflow management for operations managers.
    """
    permission_classes = [CanManageWorkflows]
    serializer_class = WorkflowSerializer
    queryset = Workflow.objects.all()

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)


class WorkflowStepViewSet(viewsets.ModelViewSet):
    """
    Handles workflow step management.
    """
    permission_classes = [CanManageWorkflows]
    serializer_class = WorkflowStepSerializer

    def get_queryset(self):
        workflow_id = self.request.query_params.get('workflow')
        if workflow_id:
            return WorkflowStep.objects.filter(workflow_id=workflow_id)
        return WorkflowStep.objects.all()

    def perform_create(self, serializer):
        serializer.save()


class ClientKYCViewSet(viewsets.ModelViewSet):
    """
    Handles Client KYC submissions and reviews.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = ClientKYCSerializer

    def get_queryset(self):
        user = self.request.user
        if user.role == 'mobile_banker':
            return ClientKYC.objects.filter(submitted_by=user)
        elif user.role in ['operations_manager', 'manager']:
            return ClientKYC.objects.all()
        return ClientKYC.objects.none()

    def get_permissions(self):
        if self.action in ['create', 'update', 'partial_update']:
            self.permission_classes = [IsMobileBanker]
        elif self.action == 'review':
            self.permission_classes = [CanReviewKYC]
        return super().get_permissions()

    @action(detail=True, methods=['post'], permission_classes=[CanReviewKYC])
    def review(self, request, pk=None):
        """
        Operations Manager: Review and approve/reject KYC application.
        """
        kyc = self.get_object()
        action_taken = request.data.get('action')  # 'approve' or 'reject'
        notes = request.data.get('notes', '')

        if action_taken not in ['approve', 'reject']:
            return Response({'error': 'Invalid action. Use "approve" or "reject".'}, status=status.HTTP_400_BAD_REQUEST)

        from django.utils import timezone
        kyc.status = 'Approved' if action_taken == 'approve' else 'Rejected'
        kyc.reviewed_by = request.user
        kyc.reviewed_at = timezone.now()
        kyc.save()

        return Response({'message': f'KYC {action_taken}d successfully.', 'status': kyc.status}, status=status.HTTP_200_OK)


class FieldCollectionViewSet(viewsets.ModelViewSet):
    """
    Handles field collection operations for mobile bankers.
    """
    permission_classes = [IsMobileBanker]
    serializer_class = FieldCollectionSerializer

    def get_queryset(self):
        return FieldCollection.objects.filter(collected_by=self.request.user)

    def perform_create(self, serializer):
        serializer.save(collected_by=self.request.user)


class ExpenseViewSet(viewsets.ModelViewSet):
    """
    Handles expense tracking and management.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = ExpenseSerializer
    queryset = Expense.objects.all()

    def get_queryset(self):
        user = self.request.user
        if user.role in ['manager', 'operations_manager']:
            return Expense.objects.all()
        return Expense.objects.filter(recorded_by=user)

    def perform_create(self, serializer):
        serializer.save(recorded_by=self.request.user)

    @action(detail=True, methods=['post'], permission_classes=[IsOperationsManager])
    def approve(self, request, pk=None):
        """
        Approve an expense (Operations Manager only).
        """
        expense = self.get_object()
        expense.is_approved = True
        expense.approved_by = request.user
        expense.save()
        serializer = self.get_serializer(expense)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=True, methods=['post'], permission_classes=[IsOperationsManager])
    def reject(self, request, pk=None):
        """
        Reject an expense (Operations Manager only).
        """
        expense = self.get_object()
        expense.is_approved = False
        expense.approved_by = request.user
        expense.save()
        serializer = self.get_serializer(expense)
        return Response(serializer.data, status=status.HTTP_200_OK)


class VisitScheduleViewSet(viewsets.ModelViewSet):
    """
    Handles visit scheduling for mobile bankers.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = VisitScheduleSerializer

    def get_queryset(self):
        user = self.request.user
        if user.role in ['manager', 'operations_manager']:
            return VisitSchedule.objects.all()
        return VisitSchedule.objects.filter(assigned_to=user)

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

    @action(detail=True, methods=['post'], permission_classes=[IsMobileBanker])
    def start_visit(self, request, pk=None):
        """
        Mark a visit as started (Mobile Banker only).
        """
        visit = self.get_object()
        if visit.assigned_to != request.user:
            return Response({'error': 'You can only start visits assigned to you.'}, status=status.HTTP_403_FORBIDDEN)

        geotag = request.data.get('geotag', '')
        visit.start_visit(geotag)
        serializer = self.get_serializer(visit)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=True, methods=['post'], permission_classes=[IsMobileBanker])
    def complete_visit(self, request, pk=None):
        """
        Mark a visit as completed (Mobile Banker only).
        """
        visit = self.get_object()
        if visit.assigned_to != request.user:
            return Response({'error': 'You can only complete visits assigned to you.'}, status=status.HTTP_403_FORBIDDEN)

        completion_notes = request.data.get('completion_notes', '')
        geotag = request.data.get('geotag', '')
        visit.mark_completed(completion_notes, geotag)
        serializer = self.get_serializer(visit)
        return Response(serializer.data, status=status.HTTP_200_OK)


class CommissionViewSet(viewsets.ModelViewSet):
    """
    Handles commission tracking and reporting.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = CommissionSerializer
    queryset = Commission.objects.all()

    def get_queryset(self):
        user = self.request.user
        if user.role in ['manager', 'operations_manager']:
            return Commission.objects.all()
        return Commission.objects.filter(earned_by=user)

    @action(detail=False, methods=['get'])
    def summary(self, request):
        """
        Get commission summary with daily, weekly, and monthly breakdowns.
        """
        now = timezone.now()
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        week_start = today_start - timedelta(days=today_start.weekday())
        month_start = today_start.replace(day=1)

        # Get all commissions for the user or all if manager
        if request.user.role in ['manager', 'operations_manager']:
            base_queryset = Commission.objects.all()
        else:
            base_queryset = Commission.objects.filter(earned_by=request.user)

        # Daily summary
        daily_commissions = base_queryset.filter(created_at__gte=today_start)
        daily_summary = {
            'total': daily_commissions.aggregate(total=Sum('amount'))['total'] or Decimal('0.00'),
            'by_type': {}
        }
        for comm_type, _ in Commission.COMMISSION_TYPES:
            type_total = daily_commissions.filter(commission_type=comm_type).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
            daily_summary['by_type'][comm_type] = float(type_total)
        daily_summary['total'] = float(daily_summary['total'])

        # Weekly summary
        weekly_commissions = base_queryset.filter(created_at__gte=week_start)
        weekly_summary = {
            'total': weekly_commissions.aggregate(total=Sum('amount'))['total'] or Decimal('0.00'),
            'by_type': {}
        }
        for comm_type, _ in Commission.COMMISSION_TYPES:
            type_total = weekly_commissions.filter(commission_type=comm_type).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
            weekly_summary['by_type'][comm_type] = float(type_total)
        weekly_summary['total'] = float(weekly_summary['total'])

        # Monthly summary
        monthly_commissions = base_queryset.filter(created_at__gte=month_start)
        monthly_summary = {
            'total': monthly_commissions.aggregate(total=Sum('amount'))['total'] or Decimal('0.00'),
            'by_type': {}
        }
        for comm_type, _ in Commission.COMMISSION_TYPES:
            type_total = monthly_commissions.filter(commission_type=comm_type).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
            monthly_summary['by_type'][comm_type] = float(type_total)
        monthly_summary['total'] = float(monthly_summary['total'])

        # Overall statistics
        all_time_total = base_queryset.aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
        
        return Response({
            'daily': daily_summary,
            'weekly': weekly_summary,
            'monthly': monthly_summary,
            'all_time_total': float(all_time_total),
            'period_info': {
                'today': today_start.isoformat(),
                'week_start': week_start.isoformat(),
                'month_start': month_start.isoformat(),
            }
        })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def calculate_commission(request):
    """
    Calculate and record commission for a transaction.
    This endpoint can be called when processing transactions.
    """
    transaction_id = request.data.get('transaction_id')
    commission_type = request.data.get('commission_type', 'deposit')
    base_amount = Decimal(str(request.data.get('base_amount', 0)))
    percentage = Decimal(str(request.data.get('percentage', 0)))
    
    if not base_amount or not percentage:
        return Response(
            {'error': 'base_amount and percentage are required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Calculate commission amount
    commission_amount = (base_amount * percentage) / Decimal('100')
    
    # Create commission record
    commission = Commission.objects.create(
        transaction_id=transaction_id if transaction_id else None,
        commission_type=commission_type,
        amount=commission_amount,
        percentage=percentage,
        base_amount=base_amount,
        earned_by=request.user,
        description=f"{commission_type.title()} commission: {percentage}% of {base_amount}"
    )
    
    serializer = CommissionSerializer(commission)
    return Response({
        'message': 'Commission calculated and recorded successfully',
        'commission': serializer.data
    }, status=status.HTTP_201_CREATED)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_cash_flow(request):
    """
    Get comprehensive cash flow analysis with detailed breakdown of all inflows.
    Summarizes all money coming into the company from various sources.
    """
    from banking.models import Transaction, FeeTransaction, Loan, LoanRepayment
    from django.db.models import Sum, Q
    from decimal import Decimal
    
    # Get date range from query params (default to current month)
    from datetime import datetime
    now = timezone.now()
    start_date = request.GET.get('start_date')
    end_date = request.GET.get('end_date')
    
    if not start_date:
        start_date = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    else:
        start_date = datetime.fromisoformat(start_date)
    
    if not end_date:
        end_date = now
    else:
        end_date = datetime.fromisoformat(end_date)
    
    # Initialize breakdown structure
    inflow_breakdown = {
        'deposits': Decimal('0.00'),
        'loan_repayments': Decimal('0.00'),
        'interest_income': Decimal('0.00'),
        'service_charges': Decimal('0.00'),
        'fees': Decimal('0.00'),
        'transfers_in': Decimal('0.00'),
        'other': Decimal('0.00')
    }
    
    # 1. Deposits (positive deposit transactions)
    deposits = Transaction.objects.filter(
        type='deposit',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__gt=0
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    inflow_breakdown['deposits'] = deposits
    
    # 2. Loan Repayments (money coming back from loans)
    loan_repayments = LoanRepayment.objects.filter(
        payment_date__gte=start_date.date(),
        payment_date__lte=end_date.date()
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    inflow_breakdown['loan_repayments'] = loan_repayments
    
    # 3. Interest Income (interest earned on loans)
    interest_income = LoanRepayment.objects.filter(
        payment_date__gte=start_date.date(),
        payment_date__lte=end_date.date()
    ).aggregate(total=Sum('interest_paid'))['total'] or Decimal('0.00')
    inflow_breakdown['interest_income'] = interest_income
    
    # 4. Service Charges & Fees (from fee transactions)
    fees = FeeTransaction.objects.filter(
        charged_at__gte=start_date,
        charged_at__lte=end_date
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    inflow_breakdown['fees'] = fees
    
    # Also count fee-type transactions
    service_charges = Transaction.objects.filter(
        type='fee',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__lt=0  # Fees are recorded as negative for the account
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    # Convert to positive (it's income for the company)
    inflow_breakdown['service_charges'] = abs(service_charges)
    
    # 5. Transfers In (incoming transfers)
    transfers_in = Transaction.objects.filter(
        type='transfer',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__gt=0  # Positive transfers are incoming
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    inflow_breakdown['transfers_in'] = transfers_in
    
    # 6. Commissions earned (if tracked separately)
    commissions = Commission.objects.filter(
        created_at__gte=start_date,
        created_at__lte=end_date
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    
    # Calculate total inflows
    total_inflows = sum(inflow_breakdown.values()) + commissions
    
    # Calculate outflows (for net calculation)
    outflow_breakdown = {
        'withdrawals': Decimal('0.00'),
        'loan_disbursements': Decimal('0.00'),
        'transfers_out': Decimal('0.00'),
        'expenses': Decimal('0.00')
    }
    
    # Withdrawals
    withdrawals = Transaction.objects.filter(
        type='withdrawal',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__lt=0
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    outflow_breakdown['withdrawals'] = abs(withdrawals)
    
    # Loan Disbursements
    loan_disbursements = Transaction.objects.filter(
        type='loan_disbursement',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__gt=0
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    outflow_breakdown['loan_disbursements'] = loan_disbursements
    
    # Transfers Out
    transfers_out = Transaction.objects.filter(
        type='transfer',
        timestamp__gte=start_date,
        timestamp__lte=end_date,
        amount__lt=0
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    outflow_breakdown['transfers_out'] = abs(transfers_out)
    
    # Get expenses if Expense model exists
    try:
        from operations.models import Expense
        expenses = Expense.objects.filter(
            date_incurred__gte=start_date.date(),
            date_incurred__lte=end_date.date()
        ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
        outflow_breakdown['expenses'] = expenses
    except:
        pass
    
    total_outflows = sum(outflow_breakdown.values())
    net_cash_flow = total_inflows - total_outflows
    
    # Convert Decimal to float for JSON serialization
    def decimal_to_float(d):
        return {k: float(v) for k, v in d.items()}
    
    return Response({
        'period': {
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        },
        'inflows': float(total_inflows),
        'inflow_breakdown': decimal_to_float(inflow_breakdown),
        'commissions': float(commissions),
        'outflows': float(total_outflows),
        'outflow_breakdown': decimal_to_float(outflow_breakdown),
        'net': float(net_cash_flow),
        'summary': {
            'total_deposits': float(deposits),
            'total_loan_repayments': float(loan_repayments),
            'total_interest_income': float(interest_income),
            'total_fees_and_charges': float(inflow_breakdown['fees'] + inflow_breakdown['service_charges']),
            'total_commissions': float(commissions),
            'total_transfers_in': float(transfers_in)
        }
    }, status=status.HTTP_200_OK)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_operational_metrics(request):
    """
    Get operational metrics for operations manager dashboard.
    """
    from banking.models import Transaction, Account
    from django.db.models import Count
    from datetime import datetime, timedelta
    
    now = timezone.now()
    today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Calculate metrics
    transactions_today = Transaction.objects.filter(
        timestamp__gte=today_start
    ).count()
    
    failed_transactions = Transaction.objects.filter(
        timestamp__gte=today_start,
        # Add your failed transaction logic here
    ).count()
    
    # Mock data for now - replace with real calculations
    metrics = {
        'system_uptime': '99.9%',
        'transactions_today': transactions_today,
        'transaction_change': 12,
        'api_response_time': 120,
        'failed_transactions': failed_transactions,
        'failed_change': 2
    }
    
    return Response(metrics, status=status.HTTP_200_OK)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_branch_activity(request):
    """
    Get detailed branch performance analytics.
    """
    from banking.models import Branch, Transaction, Account
    from django.db.models import Count, Sum, Q, Avg
    from datetime import datetime, timedelta
    from decimal import Decimal

    # Get date range from query params (default to last 30 days)
    end_date = timezone.now()
    start_date = request.GET.get('start_date')
    if start_date:
        start_date = datetime.fromisoformat(start_date)
        if start_date.tzinfo is None:
            start_date = timezone.make_aware(start_date)
    else:
        start_date = end_date - timedelta(days=30)

    # Get all active branches
    try:
        branches = Branch.objects.filter(is_active=True)
        branches_exist = branches.exists()
    except Exception as e:
        # Handle case where Branch table doesn't exist yet
        branches = []
        branches_exist = False

    detailed_branch_data = []

    if branches_exist:
        for branch in branches:
            # Get transactions for this branch in the date range
            # Note: Since we don't have a direct branch field on transactions,
            # we'll use the cashier's branch association for now
            # In a real implementation, you might want to add a branch field to Transaction model
            branch_transactions = Transaction.objects.filter(
                timestamp__gte=start_date,
                timestamp__lte=end_date
            ).select_related('cashier')

            # Filter transactions by branch (this is a simplified approach)
            # In production, you'd want a more direct relationship
            if hasattr(branch, 'manager') and branch.manager:
                branch_transactions = branch_transactions.filter(cashier=branch.manager)

            # Calculate metrics
            total_transactions = branch_transactions.count()
            total_volume = branch_transactions.aggregate(
                total=Sum('amount')
            )['total'] or Decimal('0.00')

            # Calculate success rate (assuming all transactions are successful for now)
            success_rate = 100.0 if total_transactions > 0 else 0.0

            # Get unique accounts served by this branch
            unique_accounts = branch_transactions.values('account').distinct().count()

            # Calculate average transaction value
            avg_transaction_value = Decimal('0.00')
            if total_transactions > 0:
                avg_transaction_value = total_volume / total_transactions

            # Get transaction breakdown by type
            transaction_types = branch_transactions.values('type').annotate(
                count=Count('id'),
                volume=Sum('amount')
            )

            type_breakdown = {}
            for trans_type in transaction_types:
                type_breakdown[trans_type['type']] = {
                    'count': trans_type['count'],
                    'volume': float(trans_type['volume'] or Decimal('0.00'))
                }

            # Get daily transaction trend (last 7 days)
            daily_trend = []
            for i in range(7):
                day_start = end_date - timedelta(days=i)
                day_end = day_start + timedelta(days=1)

                day_transactions = branch_transactions.filter(
                    timestamp__gte=day_start,
                    timestamp__lte=day_end
                )

                daily_trend.append({
                    'date': day_start.date().isoformat(),
                    'count': day_transactions.count(),
                    'volume': float(day_transactions.aggregate(total=Sum('amount'))['total'] or Decimal('0.00'))
                })

            # Reverse to show oldest to newest
            daily_trend.reverse()

            branch_data = {
                'id': str(branch.id),
                'name': branch.name,
                'code': branch.code,
                'location': branch.location,
                'manager': f"{branch.manager.first_name} {branch.manager.last_name}" if branch.manager else 'Unassigned',
                'phone': branch.phone,
                'email': branch.email,
                'metrics': {
                    'total_transactions': total_transactions,
                    'total_volume': float(total_volume),
                    'success_rate': f"{success_rate:.1f}%",
                    'unique_accounts': unique_accounts,
                    'avg_transaction_value': float(avg_transaction_value),
                    'staff_count': 1 if branch.manager else 0  # Simplified for now
                },
                'transaction_breakdown': type_breakdown,
                'daily_trend': daily_trend,
                'performance_score': calculate_performance_score(total_transactions, success_rate, float(total_volume))
            }

            detailed_branch_data.append(branch_data)

    # If no branches exist, create some sample data for demonstration
    if not branches:
        detailed_branch_data = get_sample_branch_data()

    return Response(detailed_branch_data, status=status.HTTP_200_OK)


def calculate_performance_score(transaction_count, success_rate, volume):
    """
    Calculate a performance score based on various metrics.
    """
    # Simple scoring algorithm - can be made more sophisticated
    score = 0

    # Transaction count score (0-40 points)
    if transaction_count >= 1000:
        score += 40
    elif transaction_count >= 500:
        score += 30
    elif transaction_count >= 200:
        score += 20
    elif transaction_count >= 100:
        score += 10

    # Success rate score (0-35 points)
    success_rate_num = float(success_rate.replace('%', ''))
    if success_rate_num >= 99:
        score += 35
    elif success_rate_num >= 97:
        score += 25
    elif success_rate_num >= 95:
        score += 15
    elif success_rate_num >= 90:
        score += 5

    # Volume score (0-25 points)
    if volume >= 1000000:
        score += 25
    elif volume >= 500000:
        score += 15
    elif volume >= 100000:
        score += 10
    elif volume >= 50000:
        score += 5

    return min(score, 100)  # Cap at 100


def get_sample_branch_data():
    """
    Return sample branch data for demonstration when no real branches exist.
    """
    return [
        {
            'id': 'sample-1',
            'name': 'Main Branch',
            'code': 'MB',
            'location': '123 Main Street, City Center',
            'manager': 'John Smith',
            'phone': '+233-20-123-4567',
            'email': 'main.branch@coastalbank.com',
            'metrics': {
                'total_transactions': 1250,
                'total_volume': 2500000.00,
                'success_rate': '98.5%',
                'unique_accounts': 450,
                'avg_transaction_value': 2000.00,
                'staff_count': 12
            },
            'transaction_breakdown': {
                'deposit': {'count': 650, 'volume': 1800000.00},
                'withdrawal': {'count': 400, 'volume': 500000.00},
                'transfer': {'count': 200, 'volume': 200000.00}
            },
            'daily_trend': [
                {'date': '2025-10-10', 'count': 45, 'volume': 85000.00},
                {'date': '2025-10-11', 'count': 52, 'volume': 92000.00},
                {'date': '2025-10-12', 'count': 38, 'volume': 78000.00},
                {'date': '2025-10-13', 'count': 61, 'volume': 115000.00},
                {'date': '2025-10-14', 'count': 58, 'volume': 108000.00},
                {'date': '2025-10-15', 'count': 49, 'volume': 95000.00},
                {'date': '2025-10-16', 'count': 55, 'volume': 102000.00}
            ],
            'performance_score': 85
        },
        {
            'id': 'sample-2',
            'name': 'North Branch',
            'code': 'NB',
            'location': '456 North Avenue, Northern District',
            'manager': 'Sarah Johnson',
            'phone': '+233-20-234-5678',
            'email': 'north.branch@coastalbank.com',
            'metrics': {
                'total_transactions': 890,
                'total_volume': 1450000.00,
                'success_rate': '97.2%',
                'unique_accounts': 320,
                'avg_transaction_value': 1629.21,
                'staff_count': 8
            },
            'transaction_breakdown': {
                'deposit': {'count': 480, 'volume': 1200000.00},
                'withdrawal': {'count': 280, 'volume': 200000.00},
                'transfer': {'count': 130, 'volume': 50000.00}
            },
            'daily_trend': [
                {'date': '2025-10-10', 'count': 32, 'volume': 52000.00},
                {'date': '2025-10-11', 'count': 28, 'volume': 48000.00},
                {'date': '2025-10-12', 'count': 35, 'volume': 58000.00},
                {'date': '2025-10-13', 'count': 41, 'volume': 68000.00},
                {'date': '2025-10-14', 'count': 38, 'volume': 62000.00},
                {'date': '2025-10-15', 'count': 33, 'volume': 54000.00},
                {'date': '2025-10-16', 'count': 36, 'volume': 60000.00}
            ],
            'performance_score': 78
        },
        {
            'id': 'sample-3',
            'name': 'East Branch',
            'code': 'EB',
            'location': '789 East Road, Eastern District',
            'manager': 'Michael Brown',
            'phone': '+233-20-345-6789',
            'email': 'east.branch@coastalbank.com',
            'metrics': {
                'total_transactions': 654,
                'total_volume': 980000.00,
                'success_rate': '99.1%',
                'unique_accounts': 280,
                'avg_transaction_value': 1498.47,
                'staff_count': 6
            },
            'transaction_breakdown': {
                'deposit': {'count': 380, 'volume': 850000.00},
                'withdrawal': {'count': 180, 'volume': 100000.00},
                'transfer': {'count': 94, 'volume': 30000.00}
            },
            'daily_trend': [
                {'date': '2025-10-10', 'count': 24, 'volume': 36000.00},
                {'date': '2025-10-11', 'count': 22, 'volume': 33000.00},
                {'date': '2025-10-12', 'count': 28, 'volume': 42000.00},
                {'date': '2025-10-13', 'count': 31, 'volume': 46500.00},
                {'date': '2025-10-14', 'count': 29, 'volume': 43500.00},
                {'date': '2025-10-15', 'count': 26, 'volume': 39000.00},
                {'date': '2025-10-16', 'count': 30, 'volume': 45000.00}
            ],
            'performance_score': 82
        },
        {
            'id': 'sample-4',
            'name': 'West Branch',
            'code': 'WB',
            'location': '321 West Boulevard, Western District',
            'manager': 'Emily Davis',
            'phone': '+233-20-456-7890',
            'email': 'west.branch@coastalbank.com',
            'metrics': {
                'total_transactions': 432,
                'total_volume': 650000.00,
                'success_rate': '96.8%',
                'unique_accounts': 195,
                'avg_transaction_value': 1504.63,
                'staff_count': 5
            },
            'transaction_breakdown': {
                'deposit': {'count': 250, 'volume': 520000.00},
                'withdrawal': {'count': 120, 'volume': 100000.00},
                'transfer': {'count': 62, 'volume': 30000.00}
            },
            'daily_trend': [
                {'date': '2025-10-10', 'count': 16, 'volume': 24000.00},
                {'date': '2025-10-11', 'count': 14, 'volume': 21000.00},
                {'date': '2025-10-12', 'count': 18, 'volume': 27000.00},
                {'date': '2025-10-13', 'count': 21, 'volume': 31500.00},
                {'date': '2025-10-14', 'count': 19, 'volume': 28500.00},
                {'date': '2025-10-15', 'count': 17, 'volume': 25500.00},
                {'date': '2025-10-16', 'count': 20, 'volume': 30000.00}
            ],
            'performance_score': 71
        }
    ]


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_system_alerts(request):
    """
    Get system alerts and notifications.
    """
    # Mock data - replace with real alert system
    alerts = [
        {
            'id': 1,
            'type': 'warning',
            'message': 'High transaction volume detected',
            'timestamp': timezone.now().isoformat(),
            'severity': 'medium'
        },
        {
            'id': 2,
            'type': 'info',
            'message': 'System backup completed successfully',
            'timestamp': (timezone.now() - timedelta(hours=2)).isoformat(),
            'severity': 'low'
        }
    ]
    
    return Response(alerts, status=status.HTTP_200_OK)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_workflow_status(request):
    """
    Get workflow status for various operations.
    """
    from banking.models import Loan
    
    # Get real loan data
    pending_loans = Loan.objects.filter(status='pending').count()
    approved_loans = Loan.objects.filter(status='approved').count()
    
    workflow_status = {
        'loan_disbursements': {
            'completed': approved_loans,
            'pending': pending_loans
        },
        'account_onboarding': {
            'completed': 45,
            'pending': 8
        },
        'kyc_verification': {
            'completed': ClientKYC.objects.filter(status='Approved').count(),
            'pending': ClientKYC.objects.filter(status='Pending').count()
        },
        'service_charges': {
            'completed': 120,
            'pending': 15
        }
    }
    
    return Response(workflow_status, status=status.HTTP_200_OK)


@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def service_charges(request):
    """
    GET: List all service charges
    POST: Create a new service charge
    """
    from banking.models import FeeStructure
    
    if request.method == 'GET':
        # Get all fee structures
        fees = FeeStructure.objects.all()
        charges = []
        for fee in fees:
            charges.append({
                'id': fee.id,
                'name': fee.name,
                'description': fee.description or '',
                'charge_type': 'percentage' if fee.fee_type == 'percentage' else 'fixed',
                'rate': float(fee.percentage if fee.fee_type == 'percentage' else fee.fixed_amount or 0),
                'applicable_to': [fee.transaction_type] if fee.transaction_type else []
            })
        return Response(charges, status=status.HTTP_200_OK)
    
    elif request.method == 'POST':
        # Create new service charge
        data = request.data
        fee = FeeStructure.objects.create(
            name=data.get('name'),
            description=data.get('description', ''),
            fee_type=data.get('charge_type', 'percentage'),
            amount=Decimal(str(data.get('rate', 0))),
            transaction_type=data.get('applicable_to', [])[0] if data.get('applicable_to') else None
        )
        return Response({
            'id': fee.id,
            'name': fee.name,
            'message': 'Service charge created successfully'
        }, status=status.HTTP_201_CREATED)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def calculate_service_charge(request):
    """
    Calculate service charge for a transaction.
    """
    from banking.models import FeeStructure
    
    transaction_type = request.data.get('transaction_type')
    amount = Decimal(str(request.data.get('amount', 0)))
    
    # Get applicable fees
    fees = FeeStructure.objects.filter(transaction_type=transaction_type)
    
    charge_breakdown = []
    total_charge = Decimal('0.00')
    
    for fee in fees:
        if fee.fee_type == 'percentage':
            charge_amount = (amount * fee.amount) / Decimal('100')
        else:
            charge_amount = fee.amount
        
        total_charge += charge_amount
        charge_breakdown.append({
            'name': fee.name,
            'type': fee.fee_type,
            'rate': float(fee.amount),
            'amount': float(charge_amount)
        })
    
    return Response({
        'transaction_amount': float(amount),
        'total_service_charge': float(total_charge),
        'net_amount': float(amount - total_charge),
        'charge_breakdown': charge_breakdown
    }, status=status.HTTP_200_OK)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def calculate_interest(request):
    """
    Calculate interest for loans or savings accounts.
    """
    account_type = request.data.get('account_type', 'loan')  # 'loan' or 'savings'
    principal = Decimal(str(request.data.get('principal', 0)))
    rate = Decimal(str(request.data.get('rate', 0)))
    time_period = int(request.data.get('time_period', 1))  # in months
    compounding_frequency = request.data.get('compounding_frequency', 'monthly')  # 'monthly', 'quarterly', 'annually'

    if principal <= 0 or rate <= 0 or time_period <= 0:
        return Response({
            'error': 'Invalid input parameters. Principal, rate, and time_period must be positive.'
        }, status=status.HTTP_400_BAD_REQUEST)

    # Convert annual rate to decimal
    annual_rate = rate / Decimal('100')

    # Calculate interest based on compounding frequency
    if compounding_frequency == 'annually':
        periods_per_year = 1
    elif compounding_frequency == 'quarterly':
        periods_per_year = 4
    else:  # monthly
        periods_per_year = 12

    # Calculate compound interest
    periods = time_period / 12 * periods_per_year  # Convert months to periods
    if compounding_frequency == 'monthly':
        # Simple monthly compounding formula
        interest_amount = principal * (annual_rate / periods_per_year) * time_period
    else:
        # Compound interest formula: A = P(1 + r/n)^(nt)
        compound_factor = (1 + annual_rate / periods_per_year) ** periods
        final_amount = principal * compound_factor
        interest_amount = final_amount - principal

    # For loans, also calculate monthly payment if requested
    monthly_payment = None
    if account_type == 'loan' and request.data.get('calculate_payment', False):
        # Monthly payment formula for loans: PMT = P[r(1+r)^n]/[(1+r)^n-1]
        monthly_rate = annual_rate / 12
        num_payments = time_period
        if monthly_rate > 0:
            monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** num_payments) / ((1 + monthly_rate) ** num_payments - 1)

    response_data = {
        'principal': float(principal),
        'annual_rate': float(rate),
        'time_period_months': time_period,
        'compounding_frequency': compounding_frequency,
        'interest_amount': float(interest_amount),
        'final_amount': float(principal + interest_amount),
        'account_type': account_type
    }

    if monthly_payment is not None:
        response_data['monthly_payment'] = float(monthly_payment)

    return Response(response_data, status=status.HTTP_200_OK)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def generate_report(request):
    """
    Generate various types of reports.
    """
    report_type = request.data.get('type')
    date_from = request.data.get('date_from')
    date_to = request.data.get('date_to')

    from banking.models import Transaction
    from datetime import datetime

    # Parse dates and make them timezone-aware
    if date_from:
        start_date = datetime.fromisoformat(date_from)
        if start_date.tzinfo is None:
            start_date = timezone.make_aware(start_date)
    else:
        start_date = timezone.now() - timedelta(days=7)

    if date_to:
        end_date = datetime.fromisoformat(date_to)
        if end_date.tzinfo is None:
            end_date = timezone.make_aware(end_date)
    else:
        end_date = timezone.now()

    # Generate report based on type
    if report_type == 'daily_transaction':
        from django.db.models.functions import Abs

        transactions = Transaction.objects.filter(
            timestamp__gte=start_date,
            timestamp__lte=end_date
        )

        # Calculate total volume using absolute values
        total_volume = Decimal('0.00')
        for trans in transactions:
            total_volume += abs(trans.amount)

        report_data = {
            'report_type': 'Daily Transaction Report',
            'period': f"{start_date.date()} to {end_date.date()}",
            'total_transactions': transactions.count(),
            'total_volume': float(total_volume),
            'by_type': {}
        }

        for trans_type in ['deposit', 'withdrawal', 'transfer']:
            type_trans = transactions.filter(type=trans_type)
            type_volume = Decimal('0.00')
            for trans in type_trans:
                type_volume += abs(trans.amount)

            report_data['by_type'][trans_type] = {
                'count': type_trans.count(),
                'volume': float(type_volume)
            }

    elif report_type == 'system_performance':
        report_data = {
            'report_type': 'System Performance Report',
            'period': f"{start_date.date()} to {end_date.date()}",
            'uptime': '99.9%',
            'avg_response_time': '120ms',
            'total_requests': 15420,
            'failed_requests': 23
        }

    elif report_type == 'staff_activity':
        report_data = {
            'report_type': 'Staff Activity Report',
            'period': f"{start_date.date()} to {end_date.date()}",
            'total_staff': User.objects.exclude(role='member').count(),
            'active_staff': User.objects.exclude(role='member').filter(is_active=True).count(),
            'transactions_processed': Transaction.objects.filter(
                timestamp__gte=start_date,
                timestamp__lte=end_date
            ).count()
        }

    elif report_type == 'security_audit':
        report_data = {
            'report_type': 'Security Audit Report',
            'period': f"{start_date.date()} to {end_date.date()}",
            'failed_login_attempts': 12,
            'suspicious_activities': 3,
            'security_incidents': 0,
            'compliance_status': 'Compliant'
        }

    else:
        return Response({'error': 'Invalid report type'}, status=status.HTTP_400_BAD_REQUEST)

    return Response(report_data, status=status.HTTP_200_OK)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_mobile_banker_metrics(request):
    """
    Get metrics for mobile banker dashboard: scheduled visits, collections today, collections due, new applications.
    """
    from banking.models import LoanApplication, Transaction, Account
    from django.db.models import Sum, Q
    from decimal import Decimal

    user = request.user
    today = timezone.now().date()
    today_start = timezone.now().replace(hour=0, minute=0, second=0, microsecond=0)

    # 1. Scheduled Visits - visits assigned to this mobile banker that are scheduled or in progress
    scheduled_visits = VisitSchedule.objects.filter(
        assigned_to=user,
        status__in=['scheduled', 'in_progress']
    ).count()

    # 2. Completed Today - visits completed today
    completed_today = VisitSchedule.objects.filter(
        assigned_to=user,
        status='completed',
        actual_end_time__gte=today_start
    ).count()

    # 3. Collections Due - outstanding loan repayments due
    from banking.models import LoanRepayment
    try:
        collections_due = LoanRepayment.objects.filter(
            loan__account__owner=user,  # Assuming mobile banker owns the accounts they collect from
            payment_date__lte=today,
            amount__gt=0
        ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')
    except:
        collections_due = Decimal('0.00')

    # 4. New Applications - loan applications submitted today
    new_applications = LoanApplication.objects.filter(
        submitted_at__gte=today_start
    ).count()

    # For demonstration, let's also calculate some collection metrics
    # Collections today - payments received today
    collections_today_amount = Transaction.objects.filter(
        type__in=['deposit', 'loan_repayment'],
        timestamp__gte=today_start,
        amount__gt=0
    ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')

    return Response({
        'scheduled_visits': scheduled_visits,
        'completed_today': completed_today,
        'collections_due': float(collections_due),
        'new_applications': new_applications,
        'collections_today_amount': float(collections_today_amount)
    }, status=status.HTTP_200_OK)


class MessageViewSet(viewsets.ModelViewSet):
    """
    Handles messaging functionality for users.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = MessageSerializer

    def get_queryset(self):
        user = self.request.user
        return Message.objects.filter(
            models.Q(sender=user) | models.Q(recipient=user)
        ).order_by('-created_at')

    def perform_create(self, serializer):
        serializer.save(sender=self.request.user)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def mark_read(self, request, pk=None):
        """Mark a message as read"""
        message = self.get_object()
        if message.recipient == request.user:
            message.mark_as_read()
            serializer = self.get_serializer(message)
            return Response(serializer.data, status=status.HTTP_200_OK)
        return Response({'error': 'You can only mark your own messages as read'}, status=status.HTTP_403_FORBIDDEN)
