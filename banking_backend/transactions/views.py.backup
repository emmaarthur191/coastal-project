import uuid
import logging
from decimal import Decimal
from django.db import transaction as db_transaction
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.shortcuts import get_object_or_404
from banking.models import Account, Transaction, FeeStructure, FeeTransaction, Loan, LoanRepayment
from banking.permissions import IsCashier, IsMemberOrStaff, IsOperationsManager, IsMobileBanker
from banking_backend.utils.exceptions import InsufficientFundsException, ValidationException, PermissionDeniedException, AccountNotFoundException, InvalidTransactionException, RateLimitExceededException
from banking_backend.utils.audit import AuditService, audit_context
from banking_backend.utils.sanitizer import Sanitizer
from .serializers import TransactionSerializer, FastTransferSerializer
from banking.serializers import (
    TransactionListSerializer, AccountSummarySerializer, FrontendAccountSummarySerializer,
    LoanSerializer, LoanRepaymentSerializer, FeeStructureSerializer, FeeTransactionSerializer
)

logger = logging.getLogger(__name__)


class TransactionViewSet(viewsets.GenericViewSet):
    """
    Handles transaction operations including history, processing, transfers, and account summaries.
    Uses TransactionListSerializer for frontend compatibility in list operations.
    Endpoint: /api/v1/transactions/process/
    """
    permission_classes = [IsAuthenticated]
    serializer_class = TransactionSerializer

    def get_queryset(self):
        # Members only see their own transactions, staff see all
        if self.request.user.role == 'member':
            return Transaction.objects.filter(account__owner=self.request.user)
        return Transaction.objects.all()

    def get_serializer_class(self):
        """Return appropriate serializer based on action"""
        if self.action == 'list':
            return TransactionListSerializer
        return TransactionSerializer

    def list(self, request):
        """
        Member/Staff: View Transaction History (GET /api/v1/transactions/).
        Returns frontend-compatible data structure.
        """
        transactions = self.get_queryset().order_by('-timestamp')[:50]
        serializer = TransactionListSerializer(transactions, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'], permission_classes=[IsCashier])
    def process(self, request):
        """
        Cashier: Fast intake for deposit/withdrawal. (POST /api/v1/transactions/process/)
        Requires: member_id (UUID), amount, type.
        Enhanced with rate limiting and comprehensive validation.
        """
        member_id = request.data.get('member_id')
        amount_str = request.data.get('amount')
        trans_type = request.data.get('type')

        try:
            with audit_context(request.user):
                from users.models import User

                # 1. Validation and Lookup
                try:
                    member_user = User.objects.get(id=member_id)
                except User.DoesNotExist:
                    raise AccountNotFoundException("Member not found")

                try:
                    member_account = Account.objects.get(owner=member_user, type='Savings')
                except Account.DoesNotExist:
                    raise AccountNotFoundException("Savings account not found for member")

                try:
                    amount = Decimal(amount_str)
                except (ValueError, TypeError):
                    raise ValidationException("Invalid amount format")

                if amount <= 0:
                    raise ValidationException("Amount must be positive")

                # Validate transaction type - support both formats
                valid_types = ['Deposit', 'Withdrawal', 'deposit', 'withdrawal']
                if trans_type not in valid_types:
                    raise InvalidTransactionException(f"Invalid transaction type. Must be one of: {', '.join(valid_types)}")

                old_balance = member_account.balance

                # 2. Business Logic (Deposit/Withdrawal) - wrapped in atomic transaction
                with db_transaction.atomic():
                    if trans_type in ['Deposit', 'deposit']:
                        member_account.balance += amount
                        transaction_amount = amount
                    elif trans_type in ['Withdrawal', 'withdrawal']:
                        if member_account.balance < amount:
                            raise InsufficientFundsException()
                        member_account.balance -= amount
                        transaction_amount = -amount  # Store withdrawals as negative
                    else:
                        raise InvalidTransactionException("Invalid transaction type")

                    member_account.save()

                    # 3. Record Transaction
                    transaction = Transaction.objects.create(
                        account=member_account,
                        type=trans_type.capitalize(),  # Ensure consistent capitalization
                        amount=transaction_amount,
                        cashier=request.user
                    )

                    # 4. Audit logging
                    AuditService.log_transaction(request.user, transaction)
                    AuditService.log_account_balance_change(
                        request.user, member_account, old_balance, member_account.balance,
                        f"{trans_type} transaction"
                    )

                # 5. Confirmation & Receipt Logic
                return Response({
                    'message': f'Transaction successful. New balance: ${member_account.balance}',
                    'receipt_id': str(uuid.uuid4())
                }, status=status.HTTP_200_OK)

        except (InsufficientFundsException, InvalidTransactionException,
                AccountNotFoundException, ValidationException) as e:
            # Custom exceptions are handled by the exception handler
            raise
        except Exception as e:
            logger.error(f"Unexpected error in transaction processing: {str(e)}", exc_info=True)
            raise ValidationException("Transaction processing failed")

    @action(detail=False, methods=['post'], permission_classes=[IsCashier])
    def transfer(self, request):
        """
        Process account transfer between two accounts.
        """
        from_account_id = request.data.get('from_account')
        to_account_id = request.data.get('to_account')
        amount = Decimal(request.data.get('amount'))

        if amount <= 0:
            return Response({'error': 'Invalid transfer amount'}, status=status.HTTP_400_BAD_REQUEST)

        from_account = get_object_or_404(Account, id=from_account_id)
        to_account = get_object_or_404(Account, id=to_account_id)

        if from_account.balance < amount:
            return Response({'error': 'Insufficient funds'}, status=status.HTTP_400_BAD_REQUEST)

        with db_transaction.atomic():
            # Debit from source
            from_account.balance -= amount
            from_account.save()

            # Credit to destination
            to_account.balance += amount
            to_account.save()

            # Create transaction records
            Transaction.objects.create(
                account=from_account,
                type='transfer',
                amount=-amount,
                cashier=request.user,
                related_account=to_account,
                description=f'Transfer to {to_account.get_decrypted_account_number()}'
            )

            Transaction.objects.create(
                account=to_account,
                type='transfer',
                amount=amount,
                cashier=request.user,
                related_account=from_account,
                description=f'Transfer from {from_account.get_decrypted_account_number()}'
            )

        return Response({'message': 'Transfer completed successfully'}, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'], permission_classes=[IsCashier])
    def process_enhanced(self, request):
        """
        Enhanced transaction processing with automatic fee calculation.
        """
        member_id = request.data.get('member_id')
        amount = Decimal(request.data.get('amount'))
        trans_type = request.data.get('type')

        member_user = get_object_or_404(User, id=member_id)
        member_account = get_object_or_404(Account, owner=member_user, type='Savings')

        # Calculate fee
        try:
            fee_structure = FeeStructure.objects.get(transaction_type=trans_type, is_active=True)
            fee_amount = fee_structure.calculate_fee(amount)
        except FeeStructure.DoesNotExist:
            fee_amount = Decimal('0.00')

        total_amount = amount + fee_amount

        with db_transaction.atomic():
            if trans_type == 'withdrawal':
                if member_account.balance < total_amount:
                    return Response({'error': 'Insufficient funds'}, status=status.HTTP_400_BAD_REQUEST)
                member_account.balance -= total_amount
            elif trans_type == 'deposit':
                member_account.balance += amount  # Fee is charged separately
            else:
                return Response({'error': 'Unsupported transaction type'}, status=status.HTTP_400_BAD_REQUEST)

            member_account.save()

            # Create main transaction
            transaction = Transaction.objects.create(
                account=member_account,
                type=trans_type,
                amount=amount if trans_type == 'deposit' else -amount,
                cashier=request.user
            )

            # Create fee transaction if applicable
            if fee_amount > 0:
                FeeTransaction.objects.create(
                    transaction=transaction,
                    fee_structure=fee_structure,
                    amount=fee_amount
                )

                # Create fee transaction record
                Transaction.objects.create(
                    account=member_account,
                    type='fee',
                    amount=-fee_amount,
                    cashier=request.user,
                    description=f'Fee for {trans_type}'
                )

        return Response({
            'message': f'{trans_type.capitalize()} processed successfully',
            'fee_charged': str(fee_amount),
            'new_balance': str(member_account.balance)
        }, status=status.HTTP_200_OK)

    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def account_summary(self, request):
        """
        Get account summary data for the current user or all users (if manager).
        Endpoint: /api/v1/transactions/account-summary/
        """
        try:
            user = request.user
            if user.role == 'member':
                accounts = Account.objects.filter(owner=user)
            else:
                accounts = Account.objects.all()
            
            # Calculate summary data
            total_savings = Decimal('0.00')
            total_loans = Decimal('0.00')
            available_balance = Decimal('0.00')
            monthly_contributions = Decimal('0.00')
            account_count = accounts.count()
            loan_count = 0

            for account in accounts:
                if account.type in ['Savings', 'Shares']:
                    total_savings += account.balance
                    available_balance += account.balance
                elif account.type == 'Checking':
                    available_balance += account.balance

            # Calculate loans and monthly contributions
            if user.role == 'member':
                loans = Loan.objects.filter(account__owner=user)
                loan_count = loans.count()
                total_loans = sum(loan.outstanding_balance for loan in loans)
                
                # Monthly contributions (last month deposits)
                from django.utils import timezone
                from datetime import timedelta
                
                last_month = timezone.now() - timedelta(days=30)
                transactions = Transaction.objects.filter(
                    account__owner=user,
                    type='deposit',
                    timestamp__gte=last_month
                )
                monthly_contributions = sum(trans.amount for trans in transactions)
            else:
                loans = Loan.objects.all()
                loan_count = loans.count()
                total_loans = sum(loan.outstanding_balance for loan in loans)
                
                # Monthly contributions for all users
                from django.utils import timezone
                from datetime import timedelta
                
                last_month = timezone.now() - timedelta(days=30)
                transactions = Transaction.objects.filter(
                    type='deposit',
                    timestamp__gte=last_month
                )
                monthly_contributions = sum(trans.amount for trans in transactions)

            summary_data = {
                'total_savings': total_savings,
                'total_loans': total_loans,
                'available_balance': available_balance,
                'monthly_contributions': monthly_contributions,
                'account_count': account_count,
                'loan_count': loan_count
            }

            serializer = FrontendAccountSummarySerializer(summary_data)
            return Response(serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Error generating account summary: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Failed to generate account summary'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class FastTransferView(viewsets.GenericViewSet):
    """
    Handles fast transfers between accounts.
    Endpoint: /api/v1/transfers/fast-transfer/
    """
    permission_classes = [IsMemberOrStaff]
    serializer_class = FastTransferSerializer

    @action(detail=False, methods=['post'])
    def fast_transfer(self, request):
        """
        Perform a fast transfer between two accounts.
        Requires: from_account (UUID), to_account (UUID), amount, description (optional).
        """
        serializer = self.get_serializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        from_account = serializer.validated_data['from_account_obj']
        to_account = serializer.validated_data['to_account_obj']
        amount = serializer.validated_data['amount']
        description = serializer.validated_data.get('description', 'Fast Transfer')

        try:
            with audit_context(request.user):
                with db_transaction.atomic():
                    # Check permissions: Members can only transfer from their own accounts
                    if request.user.role == 'member' and from_account.owner != request.user:
                        raise PermissionDeniedException("You can only transfer from your own accounts")

                    if from_account.balance < amount:
                        raise InsufficientFundsException()

                    old_from_balance = from_account.balance
                    old_to_balance = to_account.balance

                    # Deduct from source account
                    from_account.balance -= amount
                    from_account.save()

                    # Add to destination account
                    to_account.balance += amount
                    to_account.save()

                    # Record transactions
                    from_transaction = Transaction.objects.create(
                        account=from_account,
                        type='Transfer Out',
                        amount=-amount,
                        cashier=request.user if hasattr(request.user, 'role') and request.user.role in ['cashier', 'manager', 'operations_manager'] else None,
                        description=description
                    )

                    to_transaction = Transaction.objects.create(
                        account=to_account,
                        type='Transfer In',
                        amount=amount,
                        cashier=request.user if hasattr(request.user, 'role') and request.user.role in ['cashier', 'manager', 'operations_manager'] else None,
                        description=description,
                        related_account=from_account
                    )

                    # Update related account reference
                    from_transaction.related_account = to_account
                    from_transaction.save()

                    # Audit logging
                    AuditService.log_transaction(request.user, from_transaction)
                    AuditService.log_transaction(request.user, to_transaction)
                    AuditService.log_account_balance_change(
                        request.user, from_account, old_from_balance, from_account.balance,
                        f"Transfer to {to_account.get_decrypted_account_number()}"
                    )
                    AuditService.log_account_balance_change(
                        request.user, to_account, old_to_balance, to_account.balance,
                        f"Transfer from {from_account.get_decrypted_account_number()}"
                    )

                return Response({
                    'message': 'Transfer successful.',
                    'from_balance': from_account.balance,
                    'to_balance': to_account.balance,
                    'transfer_id': str(uuid.uuid4())
                }, status=status.HTTP_200_OK)

        except (InsufficientFundsException, ValidationException, PermissionDeniedException) as e:
            raise
        except Exception as e:
            logger.error(f"Unexpected error in transfer: {str(e)}", exc_info=True)
            raise ValidationException("Transfer failed")
