--- SOURCE INSPECTION ---
    def get(self, request):
        """Calculate comprehensive operational metrics for the manager dashboard."""
        _today = timezone.now().date()

        try:
            # Calculate metrics
            total_transactions_today = Transaction.objects.filter(timestamp__date=_today).count()

            total_volume_today_agg = Transaction.objects.filter(timestamp__date=_today, status="completed").aggregate(
                total=Sum("amount")
            )
            total_volume_today = total_volume_today_agg["total"] or Decimal("0")

            pending_transactions = Transaction.objects.filter(status="pending").count()
            active_accounts = Account.objects.filter(is_active=True).count()
            active_alerts = FraudAlert.objects.filter(is_resolved=False).count()
            pending_service_requests = ServiceRequest.objects.filter(status="pending").count()
            pending_refunds = Refund.objects.filter(status="pending").count()
            open_complaints = Complaint.objects.filter(status__in=["open", "in_progress"]).count()

            # Staff metrics
            from users.models import User
            active_staff = User.objects.filter(
                role__in=["staff", "cashier", "manager", "admin"], is_active=True
            ).count()

            # Calculate daily trend (last 7 days)
            daily_transactions = []
            for i in range(7):
                day = _today - datetime.timedelta(days=i)
                count = Transaction.objects.filter(timestamp__date=day).count()
                daily_transactions.append({"date": day.isoformat(), "count": count})

            # Calculate trends
            yesterday = _today - datetime.timedelta(days=1)
            transactions_yesterday = Transaction.objects.filter(timestamp__date=yesterday).count()

            if transactions_yesterday > 0:
                transaction_change = (
                    (total_transactions_today - transactions_yesterday) / transactions_yesterday
                ) * 100
                transaction_change = round(float(transaction_change), 1)
            else:
                transaction_change = 0 if total_transactions_today == 0 else 100

            # Failed transactions
            failed_today = Transaction.objects.filter(status="failed", timestamp__date=_today).count()
            failed_yesterday = Transaction.objects.filter(status="failed", timestamp__date=yesterday).count()
            failed_change = failed_today - failed_yesterday

            # API Response Time
            avg_resp_time_agg = SystemHealth.objects.filter(checked_at__date=_today, status="healthy").aggregate(
                avg=Avg("response_time_ms")
            )
            avg_resp_time = avg_resp_time_agg["avg"]

            api_response_time = int(avg_resp_time) if avg_resp_time is not None else 125

            # System Uptime
            uptime_window = timezone.now() - datetime.timedelta(days=7)
            total_health_checks = SystemHealth.objects.filter(checked_at__gte=uptime_window).count()
            healthy_checks = SystemHealth.objects.filter(checked_at__gte=uptime_window, status="healthy").count()
            if total_health_checks > 0:
                uptime_percent = (healthy_checks / total_health_checks) * 100
                system_uptime = f"{uptime_percent:.1f}%"
            else:
                system_uptime = "99.9%"

            # Pending Approvals
            pending_items = []

            # Pending Loans
            loans = Loan.objects.filter(status="pending").select_related("user").order_by("-created_at")[:10]
            for loan in loans:
                user_name = loan.user.get_full_name() if loan.user else "Unknown User"
                pending_items.append(
                    {
                        "id": str(loan.id),
                        "type": "Loan Application",
                        "description": f"{user_name} - {float(loan.amount)}",
                        "date": loan.created_at.isoformat(),
                        "status": "pending",
                    }
                )

            # Pending Account Openings
            accounts = AccountOpeningRequest.objects.filter(status="pending").order_by("-created_at")[:10]
            for acc in accounts:
                pending_items.append(
                    {
                        "id": str(acc.id),
                        "type": "Account Opening",
                        "description": f"{acc.first_name} {acc.last_name} ({acc.account_type})".strip(),
                        "date": acc.created_at.isoformat(),
                        "status": "pending",
                    }
                )

            # High-Value Transactions (Maker-Checker Phase 2)
            high_value_txs = Transaction.objects.filter(status="pending_approval").select_related("from_account", "to_account", "from_account__user", "to_account__user").order_by("-timestamp")[:10]
            for tx in high_value_txs:
                from_info = tx.from_account.user.get_full_name() if tx.from_account and tx.from_account.user else "Cash/External"
                to_info = tx.to_account.user.get_full_name() if tx.to_account and tx.to_account.user else "Cash/External"
                pending_items.append(
                    {
                        "id": str(tx.id),
                        "type": "High-Value Transaction",
                        "description": f"{from_info} - GHS {tx.amount} to {to_info}",
                        "date": tx.timestamp.isoformat(),
                        "status": "pending_approval",
                    }
                )

            # Staff Performance
            from users.models import UserActivity
            staff_perf_list = []
            active_staff_list = User.objects.filter(role__in=["cashier", "manager", "mobile_banker"], is_active=True)[:5]

            for s in active_staff_list:
                activity_count = UserActivity.objects.filter(user=s, created_at__date=_today).count()
                logged_in_today = UserActivity.objects.filter(user=s, action="login", created_at__date=_today).exists()
                efficiency = "100%" if logged_in_today else "0%"

                staff_perf_list.append(
                    {
                        "name": s.get_full_name() or s.username,
                        "role": s.get_role_display(),
                        "transactions": activity_count,
                        "efficiency": efficiency,
                    }
                )

            return Response(
                {
                    "system_uptime": system_uptime,
                    "transactions_today": total_transactions_today,
                    "transaction_change": transaction_change,
                    "api_response_time": api_response_time,
                    "failed_transactions": failed_today,
                    "failed_change": failed_change,
                    "pending_approvals": sorted(pending_items, key=lambda x: x["date"], reverse=True),
                    "staff_performance": staff_perf_list,
                    "transactions": {
                        "today": total_transactions_today,
                        "volume_today": str(total_volume_today),
                        "pending": pending_transactions,
                    },
                    "accounts": {"active": active_accounts},
                    "alerts": {"active": active_alerts},
                    "service_requests": {"pending": pending_service_requests},
                    "refunds": {"pending": pending_refunds},
                    "complaints": {"open": open_complaints},
                    "staff": {"active": active_staff},
                    "daily_trend": daily_transactions,
                }
            )
        except Exception as e:
            logger.exception(f"Detailed error in OperationsMetricsView: {e!s}")
            return Response(
                {
                    "status": "error",
                    "message": "Failed to calculate operations metrics",
                    "details": str(e) if settings.DEBUG else None,
                    "code": "METRICS_ERROR",
                },
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

--- END SOURCE ---
FAILED: 401
{'detail': ErrorDetail(string='Authentication credentials were not provided.', code='not_authenticated'), 'status': 'error'}
