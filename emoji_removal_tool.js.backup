#!/usr/bin/env node
/**
 * Comprehensive Unicode Emoji Removal Tool (Node.js Version)
 * 
 * This script systematically processes all files in the project directory to:
 * - Identify and remove Unicode emoji characters, sequences, and presentation characters
 * - Create backup copies of original files with .backup extension
 * - Preserve file timestamps, permissions, and encoding
 * - Handle edge cases including zero-width joiners, skin tone modifiers
 * - Process emojis in string literals, comments, and documentation
 * - Generate comprehensive reports with statistics per file type
 * - Validate code syntax after emoji removal
 */

const fs = require('fs');
const path = require('path');

class EmojiRemover {
    constructor(basePath = "e:/coastal") {
        this.basePath = basePath;
        this.stats = {};
        this.report = {
            timestamp: new Date().toISOString(),
            total_files_processed: 0,
            total_emojis_removed: 0,
            backup_files_created: 0,
            files_by_type: {},
            errors: [],
            syntax_validation: {}
        };
        
        // Comprehensive emoji detection patterns
        this.emojiRegex = new RegExp([
            // Basic Emoticons
            '[\\u{1F600}-\\u{1F64F}]',  // emoticons
            // Transport and Map Symbols
            '[\\u{1F680}-\\u{1F6FF}]',  // transport & map symbols
            // Miscellaneous Symbols
            '[\\u{2600}-\\u{27BF}]',   // miscellaneous symbols
            // Dingbats
            '[\\u{2700}-\\u{27BF}]',   // dingbats
            // Miscellaneous Symbols and Pictographs
            '[\\u{1F300}-\\u{1F5FF}]', // miscellaneous symbols and pictographs
            // Supplemental Symbols and Pictographs
            '[\\u{1F900}-\\u{1F9FF}]', // supplemental symbols and pictographs
            // Symbols and Pictographs Extended-A
            '[\\u{1FA70}-\\u{1FAFF}]', // symbols and pictographs extended-a
            // Additional emoji ranges
            '[\\u{1F1E6}-\\u{1F1FF}]', // regional indicator symbols
            '[\\u{1F004}-\\u{1F0CF}]', // playing cards
            '[\\u{1F194}]',            // squares & abbreviations
            '[\\u{1F201}-\\u{1F202}]', // circled numbers/letters
            '[\\u{1F232}-\\u{1F23A}]', // circled numbers
            '[\\u{1F250}-\\u{1F251}]', // enclosed ideographs
            // Zero-width joiner sequences
            '[\\u{1F3FB}-\\u{1F3FF}]', // skin tone modifiers
            '[\\u{1F9B0}-\\u{1F9B3}]', // hair components
            // Flag sequences (combining regional indicators)
            '(?:[\\u{1F1E6}-\\u{1F1FF}]){2}',  // flag pairs
            // Keycap sequences
            '[\\u{1F3FB}-\\u{1F3FF}]*[\\u0023][\\u{1F3FB}-\\u{1F3FF}]*[\\u0020][\\u{1F3FB}-\\u{1F3FF}]*[\\u0030-\\u0039][\\u{1F3FB}-\\u{1F3FF}]*',
            // Family/people sequences with ZWJ
            '(?:[\\u{1F468}\\u{1F469}\\u{1F9D1}][\\u200D])?[\\u{1F468}\\u{1F469}\\u{1F9D1}][\\u200D]?(?:[\\u{1F468}\\u{1F469}\\u{1F9D1}][\\u200D])?[\\u{1F466}\\u{1F467}\\u{1F9D2}][\\u200D]*[\\u{1F466}\\u{1F467}\\u{1F9D2}]*',
            // Complex emoji with ZWJ (diversity)
            '(?:[\\u{1F9D1}][\\u200D])?[\\u{1F9D2}][\\u200D]*',
            // General ZWJ sequences for complex emojis
            '[\\u{1F3FB}-\\u{1F3FF}]*[\\u200D][\\u{1F3FB}-\\u{1F3FF}]*',
            // Object sequences
            '[\\u{1F9D8}][\\u200D][\\u{1F9D8}]',
            // Activity sequences
            '[\\u{1F9D6}][\\u200D][\\u{1F9D6}]',
            // Profession sequences
            '[\\u{1F9D1}][\\u200D][\\u{1F4BC}]', // business
            '[\\u{1F9D1}][\\u200D][\\u{1F3EB}]', // education
            '[\\u{1F468}\\u{1F469}][\\u200D][\\u{1F3EB}]', // teacher
            // Heart sequences (variations)
            '[\\u{1F493}-\\u{1F4FF}]',
            // Weather/ground symbols
            '[\\u{1F3D4}-\\u{1F3F0}]',
            // Food & drink symbols
            '[\\u{1F32D}-\\u{1F37F}]',
            // Time symbols
            '[\\u{1F550}-\\u{1F567}]',
            // Math symbols (sometimes used as emoji)
            '[\\u{1F7E0}-\\u{1F7EB}]' // geometric shapes
        ].join('|'), 'gu');
        
        // Variation selectors
        this.variationSelectorsRegex = /[\uFE0E\uFE0F]/gu;
        this.zwjRegex = /\u200D(?!\w)/gu;
        
        // File extensions to process
        this.textExtensions = new Set([
            '.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.scss', 
            '.json', '.yaml', '.yml', '.xml', '.md', '.txt', '.rst', '.mdx',
            '.sh', '.bat', '.ps1', '.env', '.ini', '.cfg', '.conf', '.config',
            '.sql', '.dockerfile', '.dockerignore', '.gitignore', '.env.*',
            '.log', '.svg', '.csv', '.tsv', '.requirements.txt', 'package.json',
            '.gitattributes', '.gitmodules', '.editorconfig', '.eslintrc',
            '.prettierrc', '.babelrc', '.jshintrc', '.jscsrc'
        ]);
        
        this.initStats();
    }
    
    initStats() {
        const fileTypes = [
            'Python', 'JavaScript', 'TypeScript', 'HTML', 'CSS', 'JSON', 
            'Markdown', 'YAML', 'XML', 'Shell', 'Batch', 'Environment', 'Log', 'SVG', 'Other'
        ];
        fileTypes.forEach(type => {
            this.stats[type] = { files: 0, emojis_removed: 0, backup_created: 0 };
        });
    }
    
    isTextFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const basename = path.basename(filePath);
        return this.textExtensions.has(ext) || [
            'README', 'LICENSE', 'CHANGELOG', 'TODO', 'Dockerfile', 'Makefile'
        ].includes(basename);
    }
    
    countEmojis(content) {
        if (!content) return 0;
        
        // Count primary emojis
        const matches = content.match(this.emojiRegex);
        let count = matches ? matches.length : 0;
        
        // Count variation selectors
        const variationMatches = content.match(this.variationSelectorsRegex);
        count += variationMatches ? variationMatches.length : 0;
        
        return count;
    }
    
    removeEmojis(content) {
        if (!content) return content;
        
        // Remove emojis using regex
        let cleaned = content.replace(this.emojiRegex, '');
        
        // Remove variation selectors
        cleaned = cleaned.replace(this.variationSelectorsRegex, '');
        
        // Remove orphaned zero-width joiners
        cleaned = cleaned.replace(this.zwjRegex, '');
        
        return cleaned;
    }
    
    backupFile(filePath) {
        try {
            const backupPath = filePath + '.backup';
            fs.copyFileSync(filePath, backupPath, fs.constants.COPYFILE_EXCL);
            return true;
        } catch (error) {
            this.report.errors.push(`Failed to create backup for ${filePath}: ${error.message}`);
            return false;
        }
    }
    
    getFileType(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        
        if (ext === '.py') return 'Python';
        if (['.js', '.jsx'].includes(ext)) return 'JavaScript';
        if (['.ts', '.tsx'].includes(ext)) return 'TypeScript';
        if (['.html', '.htm'].includes(ext)) return 'HTML';
        if (['.css', '.scss', '.sass'].includes(ext)) return 'CSS';
        if (ext === '.json') return 'JSON';
        if (['.md', '.markdown'].includes(ext)) return 'Markdown';
        if (['.yaml', '.yml'].includes(ext)) return 'YAML';
        if (ext === '.xml') return 'XML';
        if (['.sh', '.bash', '.zsh'].includes(ext)) return 'Shell';
        if (['.bat', '.cmd'].includes(ext)) return 'Batch';
        if (ext === '.env') return 'Environment';
        if (ext === '.log') return 'Log';
        if (ext === '.svg') return 'SVG';
        
        return 'Other';
    }
    
    validateSyntax(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const ext = path.extname(filePath).toLowerCase();
            
            if (ext === '.py') {
                // Basic Python syntax validation - check for unmatched brackets, quotes
                return this.validatePythonSyntax(content);
            } else if (['.js', '.jsx', '.ts', '.tsx'].includes(ext)) {
                return this.validateJavaScriptSyntax(content);
            }
            
            return { valid: true, error: null };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }
    
    validatePythonSyntax(content) {
        try {
            // Simple bracket matching validation
            const brackets = { '(': ')', '[': ']', '{': '}', '"': '"', "'": "'" };
            const stack = [];
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                const nextChar = content[i + 1];
                
                if (char === '"' || char === "'") {
                    // Handle string literals - skip until closing quote
                    const quote = char;
                    i++;
                    while (i < content.length && content[i] !== quote) {
                        if (content[i] === '\\') i++; // Skip escaped characters
                        i++;
                    }
                } else if (brackets[char]) {
                    stack.push(char);
                } else if (brackets[stack[stack.length - 1]] === char) {
                    stack.pop();
                }
            }
            
            const valid = stack.length === 0;
            return {
                valid,
                error: valid ? null : "Unmatched brackets or quotes detected"
            };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }
    
    validateJavaScriptSyntax(content) {
        try {
            // Basic JavaScript syntax validation
            const brackets = { '(': ')', '[': ']', '{': '}', '"': '"', "'": "'", '`': '`' };
            const stack = [];
            
            let inString = false;
            let stringChar = null;
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                
                if (inString) {
                    if (char === '\\') {
                        i++; // Skip escaped characters
                    } else if (char === stringChar) {
                        inString = false;
                        stringChar = null;
                    }
                } else {
                    if (char === '"' || char === "'" || char === '`') {
                        inString = true;
                        stringChar = char;
                    } else if (brackets[char]) {
                        stack.push(char);
                    } else if (brackets[stack[stack.length - 1]] === char) {
                        stack.pop();
                    }
                }
            }
            
            const valid = stack.length === 0 && !inString;
            return {
                valid,
                error: valid ? null : "Unmatched brackets, quotes, or incomplete string literals detected"
            };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }
    
    processFile(filePath) {
        const result = {
            path: path.relative(this.basePath, filePath),
            type: this.getFileType(filePath),
            original_size: 0,
            cleaned_size: 0,
            emojis_removed: 0,
            backup_created: false,
            syntax_valid: true,
            syntax_error: null,
            processed: false
        };
        
        try {
            // Read original content
            const originalContent = fs.readFileSync(filePath, 'utf8');
            result.original_size = originalContent.length;
            
            // Count emojis before removal
            const emojiCount = this.countEmojis(originalContent);
            result.emojis_removed = emojiCount;
            
            if (emojiCount > 0) {
                // Create backup
                if (this.backupFile(filePath)) {
                    result.backup_created = true;
                    this.report.backup_files_created += 1;
                }
                
                // Remove emojis
                const cleanedContent = this.removeEmojis(originalContent);
                result.cleaned_size = cleanedContent.length;
                
                // Write cleaned content back
                fs.writeFileSync(filePath, cleanedContent, 'utf8');
                
                // Validate syntax if applicable
                const syntaxCheck = this.validateSyntax(filePath);
                result.syntax_valid = syntaxCheck.valid;
                result.syntax_error = syntaxCheck.error;
                
                // Store syntax validation results
                this.report.syntax_validation[path.relative(this.basePath, filePath)] = syntaxCheck;
                
                result.processed = true;
                this.report.total_emojis_removed += emojiCount;
                
            } else {
                // No emojis found
                result.processed = false;
                result.cleaned_size = result.original_size;
            }
            
        } catch (error) {
            result.syntax_error = `Processing error: ${error.message}`;
            this.report.errors.push(`Failed to process ${filePath}: ${error.message}`);
        }
        
        return result;
    }
    
    walkDirectory(dirPath, excludeDirs = new Set()) {
        const files = [];
        const excludeSet = new Set([
            '.git', '__pycache__', 'node_modules', '.vscode', 
            '.venv', 'venv', '.env', 'dist', 'build', 'coverage',
            '.pytest_cache', 'logs', 'tmp', 'temp'
        ]);
        
        excludeSet.forEach(dir => excludeDirs.add(dir));
        
        const walk = (currentPath) => {
            const items = fs.readdirSync(currentPath);
            
            for (const item of items) {
                const fullPath = path.join(currentPath, item);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !excludeDirs.has(item)) {
                    walk(fullPath);
                } else if (stat.isFile() && this.isTextFile(fullPath)) {
                    // Skip files that are in excluded directories
                    const relativePath = path.relative(this.basePath, fullPath);
                    const pathParts = relativePath.split(path.sep);
                    
                    if (!pathParts.some(part => excludeDirs.has(part))) {
                        files.push(fullPath);
                    }
                }
            }
        };
        
        walk(dirPath);
        return files;
    }
    
    processAllFiles() {
        console.log('üîç Starting comprehensive emoji removal process...');
        
        // Get all files to process
        const allFiles = this.walkDirectory(this.basePath);
        this.report.total_files_processed = allFiles.length;
        
        console.log(`üìÅ Found ${allFiles.length} files to process`);
        
        // Process each file
        for (let i = 0; i < allFiles.length; i++) {
            const filePath = allFiles[i];
            const relativePath = path.relative(this.basePath, filePath);
            console.log(`üìÑ Processing ${i + 1}/${allFiles.length}: ${relativePath}`);
            
            const fileResult = this.processFile(filePath);
            
            // Update statistics
            const fileType = fileResult.type;
            this.stats[fileType].files += 1;
            
            if (fileResult.emojis_removed > 0) {
                this.stats[fileType].emojis_removed += fileResult.emojis_removed;
                this.stats[fileType].backup_created += fileResult.backup_created ? 1 : 0;
            }
            
            // Add to detailed report
            if (!this.report.files_by_type[fileType]) {
                this.report.files_by_type[fileType] = { count: 0, emojis_removed: 0 };
            }
            this.report.files_by_type[fileType].count += 1;
            this.report.files_by_type[fileType].emojis_removed += fileResult.emojis_removed;
            
            // Store detailed results for files with emojis
            if (fileResult.emojis_removed > 0) {
                if (!this.report.files_processed) {
                    this.report.files_processed = [];
                }
                this.report.files_processed.push(fileResult);
            }
        }
    }
    
    generateReport() {
        const report = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Emoji Removal Report</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; }
        .summary { background: #ecf0f1; padding: 20px; border-radius: 5px; margin: 20px 0; }
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-card { background: #fff; padding: 20px; border-radius: 5px; border-left: 4px solid #3498db; }
        .stat-number { font-size: 2em; font-weight: bold; color: #2c3e50; }
        .stat-label { color: #7f8c8d; margin-top: 5px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #34495e; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .success { color: #27ae60; }
        .warning { color: #f39c12; }
        .error { color: #e74c3c; }
        .file-list { max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; }
        .badge { padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; }
        .badge-success { background: #d4edda; color: #155724; }
        .badge-error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üßπ Comprehensive Emoji Removal Report</h1>
        
        <div class="summary">
            <h2>üìä Summary</h2>
            <p><strong>Generated:</strong> ${this.report.timestamp}</p>
            <p><strong>Total Files Processed:</strong> ${this.report.total_files_processed}</p>
            <p><strong>Total Emojis Removed:</strong> <span class="success">${this.report.total_emojis_removed}</span></p>
            <p><strong>Backup Files Created:</strong> <span class="warning">${this.report.backup_files_created}</span></p>
        </div>

        <h2>üìà Statistics by File Type</h2>
        <div class="stat-grid">
`;

        for (const [fileType, stats] of Object.entries(this.stats)) {
            if (stats.files > 0) {
                report += `
            <div class="stat-card">
                <div class="stat-number">${stats.files}</div>
                <div class="stat-label">${fileType} Files</div>
                <div class="stat-number">${stats.emojis_removed}</div>
                <div class="stat-label">Emojis Removed</div>
                <div class="stat-number">${stats.backup_created}</div>
                <div class="stat-label">Backups Created</div>
            </div>
`;
            }
        }

        report += `
        </div>

        <h2>üìã Detailed File Processing Results</h2>
        <div class="file-list">
`;

        if (this.report.files_processed && this.report.files_processed.length > 0) {
            report += `
            <table>
                <thead>
                    <tr>
                        <th>File Path</th>
                        <th>Type</th>
                        <th>Emojis Removed</th>
                        <th>Backup Created</th>
                        <th>Syntax Valid</th>
                        <th>Original Size</th>
                        <th>Cleaned Size</th>
                    </tr>
                </thead>
                <tbody>
`;

            for (const fileInfo of this.report.files_processed) {
                const statusIcon = fileInfo.syntax_valid ? '‚úÖ' : '‚ùå';
                const statusClass = fileInfo.syntax_valid ? 'success' : 'error';
                const backupStatus = fileInfo.backup_created ? '‚úÖ' : '‚ùå';

                report += `
                    <tr>
                        <td>${fileInfo.path}</td>
                        <td>${fileInfo.type}</td>
                        <td class="success">${fileInfo.emojis_removed}</td>
                        <td>${backupStatus}</td>
                        <td><span class="badge badge-${statusClass}">${statusIcon} Valid</span></td>
                        <td>${fileInfo.original_size} bytes</td>
                        <td>${fileInfo.cleaned_size} bytes</td>
                    </tr>
`;
            }

            report += `
                </tbody>
            </table>
`;
        } else {
            report += '<p>No emojis were found in any files. All files are already clean! üéâ</p>';
        }

        // Add syntax validation section
        if (Object.keys(this.report.syntax_validation).length > 0) {
            report += `
        <h2>üîç Syntax Validation Results</h2>
        <div class="file-list">
            <table>
                <thead>
                    <tr>
                        <th>File</th>
                        <th>Status</th>
                        <th>Error Details</th>
                    </tr>
                </thead>
                <tbody>
`;

            for (const [filePath, validation] of Object.entries(this.report.syntax_validation)) {
                const statusIcon = validation.valid ? '‚úÖ' : '‚ùå';
                const statusClass = validation.valid ? 'success' : 'error';
                const errorMsg = validation.error || 'None';

                report += `
                    <tr>
                        <td>${filePath}</td>
                        <td><span class="badge badge-${statusClass}">${statusIcon} ${validation.valid ? 'Valid' : 'Invalid'}</span></td>
                        <td>${errorMsg}</td>
                    </tr>
`;
            }

            report += `
                </tbody>
            </table>
        </div>
`;
        }

        // Add errors section if any
        if (this.report.errors.length > 0) {
            report += `
        <h2>‚ö†Ô∏è Errors and Issues</h2>
        <div class="file-list">
            <ul>
`;
            for (const error of this.report.errors) {
                report += `                <li class='error'>${error}</li>\n`;
            }

            report += `
            </ul>
        </div>
`;
        }

        report += `
        <h2>üéØ Completion Status</h2>
        <div class="summary">
            <p><strong>Status:</strong> 
`;

        if (this.report.total_emojis_removed > 0) {
            report += '<span class="success">‚úÖ Completed - Emojis successfully removed and backups created</span></p>';
        } else {
            report += '<span class="success">‚úÖ Completed - No emojis found in any files</span></p>';
        }

        report += `
            <p><strong>Next Steps:</strong></p>
            <ul>
                <li>Review the backup files with .backup extension if needed</li>
                <li>Run tests to ensure functionality remains intact</li>
                <li>Check syntax validation results for any issues</li>
                <li>Deploy changes after validation</li>
            </ul>
        </div>
    </div>
</body>
</html>
`;

        return report;
    }
    
    saveReports() {
        // Save HTML report
        const htmlReportPath = path.join(this.basePath, 'EMOJI_REMOVAL_REPORT.html');
        fs.writeFileSync(htmlReportPath, this.generateReport(), 'utf8');
        
        // Save JSON report for programmatic access
        const jsonReportPath = path.join(this.basePath, 'EMOJI_REMOVAL_REPORT.json');
        fs.writeFileSync(jsonReportPath, JSON.stringify(this.report, null, 2), 'utf8');
        
        console.log(`üìä Reports saved:`);
        console.log(`   HTML: ${htmlReportPath}`);
        console.log(`   JSON: ${jsonReportPath}`);
    }
}

// Main execution
function main() {
    console.log('üßπ Starting Comprehensive Emoji Removal Tool (Node.js Version)');
    console.log('='.repeat(60));
    
    const remover = new EmojiRemover('e:/coastal');
    
    try {
        remover.processAllFiles();
        remover.saveReports();
        
        console.log('\n' + '='.repeat(60));
        console.log('üéâ EMOJI REMOVAL PROCESS COMPLETED!');
        console.log(`üìä Total emojis removed: ${remover.report.total_emojis_removed}`);
        console.log(`üìÅ Total files processed: ${remover.report.total_files_processed}`);
        console.log(`üíæ Backup files created: ${remover.report.backup_files_created}`);
        console.log(`üìÑ Reports generated: EMOJI_REMOVAL_REPORT.html & .json`);
        console.log('='.repeat(60));
        
    } catch (error) {
        console.error(`‚ùå Error during execution: ${error.message}`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = EmojiRemover;