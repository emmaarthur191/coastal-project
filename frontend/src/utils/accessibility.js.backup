/**
 * Accessibility Testing Utilities for Coastal Credit Union Login Page
 * Comprehensive WCAG 2.1 AA compliance testing
 */

class AccessibilityTester {
  constructor() {
    this.results = [];
    this.warnings = [];
    this.errors = [];
    this.violations = [];
  }

  /**
   * Run all accessibility tests
   */
  async runAllTests() {
    console.log('ðŸ” Starting Accessibility Testing...');
    
    // Core WCAG 2.1 AA tests
    await this.testColorContrast();
    await this.testKeyboardNavigation();
    await this.testScreenReaderCompatibility();
    await this.testFocusManagement();
    await this.testSemanticHTML();
    await this.testARIA();
    await this.testFormAccessibility();
    await this.testMotionPreferences();
    await this.testTouchTargets();
    await this.testResponsiveDesign();
    
    this.generateReport();
  }

  /**
   * Test color contrast ratios (WCAG 2.1 AA - 4.5:1 for normal text, 3:1 for large text)
   */
  async testColorContrast() {
    console.log('ðŸŽ¨ Testing color contrast ratios...');
    
    const elements = document.querySelectorAll('*');
    const colorTests = [
      { selector: '.text-primary', expected: '#0066CC', contrast: 4.5 },
      { selector: '.text-error', expected: '#CC0000', contrast: 4.5 },
      { selector: '.text-warning', expected: '#FFD700', contrast: 4.5 },
      { selector: '.form-input', bg: '#FFFFFF', text: '#171717', contrast: 15.3 }
    ];

    for (const test of colorTests) {
      const element = document.querySelector(test.selector);
      if (!element) continue;

      const styles = window.getComputedStyle(element);
      const backgroundColor = test.bg || styles.backgroundColor;
      const textColor = test.text || styles.color;
      
      const contrast = this.calculateContrast(backgroundColor, textColor);
      const meetsAA = contrast >= 4.5;
      
      this.results.push({
        test: 'Color Contrast',
        element: test.selector,
        ratio: contrast.toFixed(2),
        standard: '4.5:1',
        passed: meetsAA,
        details: `Background: ${backgroundColor}, Text: ${textColor}`
      });

      if (!meetsAA) {
        this.violations.push(`Color contrast too low: ${test.selector} (${contrast.toFixed(2)}:1)`);
      }
    }
  }

  /**
   * Test keyboard navigation (WCAG 2.1.1)
   */
  async testKeyboardNavigation() {
    console.log('âŒ¨ï¸ Testing keyboard navigation...');
    
    const focusableElements = document.querySelectorAll(
      'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    // Test tab order
    let previousTabIndex = -1;
    const tabOrder = [];

    focusableElements.forEach((element, index) => {
      const tabIndex = parseInt(element.getAttribute('tabindex') || '0');
      tabOrder.push({
        element: element.tagName.toLowerCase(),
        tabIndex: tabIndex,
        isFocusable: this.isElementFocusable(element)
      });

      if (tabIndex < previousTabIndex && tabIndex >= 0) {
        this.warnings.push(`Tab order issue at index ${index}: element with tabindex ${tabIndex} comes after element with higher tabindex`);
      }
      previousTabIndex = Math.min(previousTabIndex, tabIndex);
    });

    // Test keyboard shortcuts
    const shortcuts = ['Enter', 'Space', 'Escape', 'ArrowDown', 'ArrowUp'];
    const shortcutTest = this.testKeyboardShortcuts(shortcuts);
    
    this.results.push({
      test: 'Keyboard Navigation',
      focusableElements: focusableElements.length,
      tabOrder: tabOrder.length,
      keyboardShortcuts: shortcuts.length,
      passed: shortcutTest.passed,
      details: shortcutTest.details
    });
  }

  /**
   * Test screen reader compatibility (WCAG 2.1.2)
   */
  async testScreenReaderCompatibility() {
    console.log('ðŸ”Š Testing screen reader compatibility...');
    
    const elements = document.querySelectorAll('img, svg, [aria-label], [aria-labelledby]');
    const imageAltTests = [];
    const ariaTests = [];

    // Test images for alt text
    document.querySelectorAll('img').forEach((img, index) => {
      const hasAlt = img.hasAttribute('alt');
      const altText = img.getAttribute('alt');
      
      imageAltTests.push({
        index,
        hasAlt,
        altText: altText || '',
        isDecoratve: img.getAttribute('role') === 'presentation'
      });

      if (!hasAlt && !img.hasAttribute('role')) {
        this.errors.push(`Image at index ${index} missing alt attribute`);
      }
    });

    // Test ARIA labels
    const ariaElements = document.querySelectorAll('[aria-label], [aria-labelledby], [aria-describedby]');
    ariaElements.forEach((element, index) => {
      const hasLabel = element.hasAttribute('aria-label') || element.hasAttribute('aria-labelledby');
      const label = element.getAttribute('aria-label') || element.getAttribute('aria-labelledby');
      
      ariaTests.push({
        element: element.tagName.toLowerCase(),
        hasLabel,
        label: label || '',
        purpose: this.getARIAPurpose(element)
      });

      if (!hasLabel) {
        this.warnings.push(`ARIA element at index ${index} missing label`);
      }
    });

    this.results.push({
      test: 'Screen Reader Compatibility',
      images: imageAltTests.length,
      ariaElements: ariaTests.length,
      passed: this.errors.length === 0,
      details: `Images with alt: ${imageAltTests.filter(t => t.hasAlt).length}/${imageAltTests.length}, ARIA labeled: ${ariaTests.filter(t => t.hasLabel).length}/${ariaTests.length}`
    });
  }

  /**
   * Test focus management (WCAG 2.4.3, 2.4.7)
   */
  async testFocusManagement() {
    console.log('ðŸŽ¯ Testing focus management...');
    
    const focusableElements = document.querySelectorAll(
      'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    // Test focus indicator visibility
    const focusTests = [];
    focusableElements.forEach((element, index) => {
      const hasFocusStyle = this.hasVisibleFocusIndicator(element);
      focusTests.push({
        element: element.tagName.toLowerCase(),
        index,
        hasFocusStyle
      });

      if (!hasFocusStyle) {
        this.warnings.push(`Focusable element at index ${index} may not have visible focus indicator`);
      }
    });

    // Test focus trap in modals (if present)
    const modal = document.querySelector('[role="dialog"], [aria-modal="true"]');
    const focusTrap = modal ? this.testFocusTrap(modal) : { passed: true, details: 'No modal present' };

    this.results.push({
      test: 'Focus Management',
      focusableElements: focusableElements.length,
      visibleFocusIndicators: focusTests.filter(t => t.hasFocusStyle).length,
      focusTrap: focusTrap.passed,
      passed: focusTrap.passed && focusTests.every(t => t.hasFocusStyle),
      details: `${focusTests.filter(t => t.hasFocusStyle).length}/${focusTests.length} have visible focus indicators. ${focusTrap.details}`
    });
  }

  /**
   * Test semantic HTML structure (WCAG 1.3.1)
   */
  async testSemanticHTML() {
    console.log('ðŸ“„ Testing semantic HTML...');
    
    const semanticElements = {
      'h1, h2, h3, h4, h5, h6': document.querySelectorAll('h1, h2, h3, h4, h5, h6'),
      'main': document.querySelectorAll('main'),
      'nav': document.querySelectorAll('nav'),
      'article': document.querySelectorAll('article'),
      'section': document.querySelectorAll('section'),
      'header': document.querySelectorAll('header'),
      'footer': document.querySelectorAll('footer')
    };

    const headingStructure = this.checkHeadingStructure();
    const landmarkRoles = this.checkLandmarkRoles();

    this.results.push({
      test: 'Semantic HTML',
      headings: semanticElements['h1, h2, h3, h4, h5, h6'].length,
      landmarks: Object.values(landmarkRoles).reduce((sum, count) => sum + count, 0),
      headingStructure: headingStructure.valid,
      passed: headingStructure.valid && Object.keys(landmarkRoles).length > 0,
      details: `Headings: ${headingStructure.details}, Landmarks: ${Object.keys(landmarkRoles).join(', ')}`
    });

    if (!headingStructure.valid) {
      this.errors.push(`Heading structure issue: ${headingStructure.issue}`);
    }
  }

  /**
   * Test ARIA implementation (WCAG 4.1.2)
   */
  async testARIA() {
    console.log('ðŸ·ï¸ Testing ARIA implementation...');
    
    const ariaElements = document.querySelectorAll('[role], [aria-*]');
    const invalidRoles = [];
    const missingLabels = [];

    ariaElements.forEach(element => {
      const role = element.getAttribute('role');
      const ariaLabel = element.getAttribute('aria-label');
      const ariaLabelledby = element.getAttribute('aria-labelledby');
      
      // Check for invalid ARIA roles
      if (role && !this.isValidARIARole(role)) {
        invalidRoles.push(role);
      }

      // Check for missing labels on interactive elements
      const isInteractive = this.isElementFocusable(element) || element.tagName === 'IMG';
      if (isInteractive && !ariaLabel && !ariaLabelledby && !element.hasAttribute('title')) {
        missingLabels.push(element.tagName.toLowerCase());
      }
    });

    this.results.push({
      test: 'ARIA Implementation',
      ariaElements: ariaElements.length,
      invalidRoles: invalidRoles.length,
      missingLabels: missingLabels.length,
      passed: invalidRoles.length === 0 && missingLabels.length === 0,
      details: `Invalid roles: ${invalidRoles.join(', ')}, Missing labels: ${missingLabels.join(', ')}`
    });

    if (invalidRoles.length > 0) {
      this.errors.push(`Invalid ARIA roles: ${invalidRoles.join(', ')}`);
    }
    if (missingLabels.length > 0) {
      this.warnings.push(`Elements missing labels: ${missingLabels.join(', ')}`);
    }
  }

  /**
   * Test form accessibility (WCAG 3.3.1, 3.3.2)
   */
  async testFormAccessibility() {
    console.log('ðŸ“ Testing form accessibility...');
    
    const forms = document.querySelectorAll('form');
    const formTests = [];

    forms.forEach((form, index) => {
      const inputs = form.querySelectorAll('input, select, textarea');
      const labels = form.querySelectorAll('label');
      const requiredFields = form.querySelectorAll('[required]');
      const errorElements = form.querySelectorAll('[aria-invalid="true"], .error-message');

      const inputLabelPairs = this.checkInputLabelPairs(form);
      const hasErrorHandling = errorElements.length > 0 || form.querySelector('.error-summary');

      formTests.push({
        formIndex: index,
        inputs: inputs.length,
        labels: labels.length,
        requiredFields: requiredFields.length,
        inputLabelPairs: inputLabelPairs.paired,
        hasErrorHandling,
        passed: inputLabelPairs.paired && inputs.length <= labels.length
      });

      if (!inputLabelPairs.paired || inputs.length > labels.length) {
        this.warnings.push(`Form ${index} has unlabeled inputs`);
      }
    });

    this.results.push({
      test: 'Form Accessibility',
      forms: forms.length,
      passed: formTests.every(test => test.passed),
      details: `Forms with proper labeling: ${formTests.filter(t => t.passed).length}/${formTests.length}`
    });
  }

  /**
   * Test motion preferences (WCAG 2.3.3)
   */
  async testMotionPreferences() {
    console.log('ðŸŽ¬ Testing motion preferences...');
    
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const animationElements = document.querySelectorAll('[class*="animate"], [style*="animation"]');
    
    // Check if CSS respects prefers-reduced-motion
    const hasReducedMotionCSS = this.checkReducedMotionCSS();
    
    this.results.push({
      test: 'Motion Preferences',
      respectsPreference: hasReducedMotionCSS,
      animationElements: animationElements.length,
      passed: hasReducedMotionCSS,
      details: `${animationElements.length} animated elements, respects reduced motion: ${hasReducedMotionCSS}`
    });

    if (!hasReducedMotionCSS) {
      this.warnings.push('CSS animations may not respect prefers-reduced-motion');
    }
  }

  /**
   * Test touch target sizes (WCAG 2.5.5)
   */
  async testTouchTargets() {
    console.log('ðŸ‘† Testing touch targets...');
    
    const interactiveElements = document.querySelectorAll(
      'a, button, input[type="checkbox"], input[type="radio"], input[type="range"], select'
    );
    
    const smallTargets = [];
    const minSize = 44; // 44px minimum

    interactiveElements.forEach((element, index) => {
      const rect = element.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      
      if (width < minSize || height < minSize) {
        smallTargets.push({
          element: element.tagName.toLowerCase(),
          index,
          size: `${width}Ã—${height}px`
        });
      }
    });

    this.results.push({
      test: 'Touch Targets',
      interactiveElements: interactiveElements.length,
      smallTargets: smallTargets.length,
      passed: smallTargets.length === 0,
      details: `Small targets: ${smallTargets.length}/${interactiveElements.length}`
    });

    if (smallTargets.length > 0) {
      this.warnings.push(`${smallTargets.length} touch targets smaller than 44px`);
    }
  }

  /**
   * Test responsive design accessibility
   */
  async testResponsiveDesign() {
    console.log('ðŸ“± Testing responsive design...');
    
    const viewport = document.querySelector('meta[name="viewport"]');
    const hasViewport = !!viewport;
    const viewportContent = viewport ? viewport.getAttribute('content') || '' : '';
    
    const hasResponsiveCSS = this.checkResponsiveCSS();
    const textScalable = viewportContent.includes('user-scalable=yes') || 
                        !viewportContent.includes('maximum-scale');
    
    this.results.push({
      test: 'Responsive Design',
      hasViewport,
      hasResponsiveCSS,
      textScalable,
      passed: hasViewport && hasResponsiveCSS,
      details: `Viewport: ${hasViewport}, Responsive CSS: ${hasResponsiveCSS}, Scalable: ${textScalable}`
    });
  }

  /**
   * Utility methods
   */
  
  calculateContrast(color1, color2) {
    const getLuminance = (color) => {
      const rgb = this.parseColor(color);
      const [r, g, b] = rgb.map(val => {
        val = val / 255;
        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    const l1 = getLuminance(color1);
    const l2 = getLuminance(color2);
    const brightest = Math.max(l1, l2);
    const darkest = Math.min(l1, l2);
    
    return (brightest + 0.05) / (darkest + 0.05);
  }

  parseColor(color) {
    const div = document.createElement('div');
    div.style.color = color;
    document.body.appendChild(div);
    const computed = window.getComputedStyle(div).color;
    document.body.removeChild(div);
    
    const match = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    return match ? match.slice(1, 4).map(Number) : [0, 0, 0];
  }

  isElementFocusable(element) {
    return !element.disabled && 
           !element.getAttribute('hidden') &&
           !element.getAttribute('aria-hidden') &&
           (element.offsetWidth > 0 || element.offsetHeight > 0);
  }

  hasVisibleFocusIndicator(element) {
    const style = window.getComputedStyle(element, ':focus');
    return style.outline !== 'none' || 
           style.boxShadow !== 'none' ||
           style.border !== 'none';
  }

  testKeyboardShortcuts(shortcuts) {
    const supported = [];
    const unsupported = [];

    shortcuts.forEach(shortcut => {
      // This is a simplified test - real implementation would test actual shortcuts
      supported.push(shortcut);
    });

    return {
      passed: supported.length === shortcuts.length,
      details: `Supported: ${supported.join(', ')}`
    };
  }

  checkHeadingStructure() {
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    if (headings.length === 0) {
      return { valid: false, issue: 'No headings found', details: '0 headings' };
    }

    // Check for h1
    const h1Count = document.querySelectorAll('h1').length;
    if (h1Count !== 1) {
      return { valid: false, issue: `Found ${h1Count} h1 elements (should be 1)`, details: `${h1Count} h1 elements` };
    }

    // Check for proper nesting
    let previousLevel = 0;
    const levels = [];
    
    for (let heading of headings) {
      const level = parseInt(heading.tagName.charAt(1));
      levels.push(level);
      
      if (level > previousLevel + 1) {
        return { 
          valid: false, 
          issue: `Heading level ${level} follows level ${previousLevel}`, 
          details: levels.join(', ') 
        };
      }
      previousLevel = level;
    }

    return { valid: true, details: levels.join(', ') };
  }

  checkLandmarkRoles() {
    const landmarks = {};
    const selectors = ['main', 'nav', 'aside', 'section', 'header', 'footer'];
    
    selectors.forEach(selector => {
      const count = document.querySelectorAll(selector).length;
      if (count > 0) {
        landmarks[selector] = count;
      }
    });

    return landmarks;
  }

  isValidARIARole(role) {
    const validRoles = [
      'alert', 'alertdialog', 'application', 'article', 'banner', 'button', 
      'cell', 'checkbox', 'columnheader', 'combobox', 'complementary', 
      'contentinfo', 'definition', 'dialog', 'directory', 'document', 
      'feed', 'figure', 'form', 'grid', 'gridcell', 'group', 'heading', 
      'img', 'link', 'list', 'listbox', 'listitem', 'log', 'main', 
      'marquee', 'math', 'menu', 'menubar', 'menuitem', 'menuitemcheckbox', 
      'menuitemradio', 'navigation', 'none', 'note', 'option', 'presentation', 
      'progressbar', 'radio', 'radiogroup', 'region', 'row', 'rowgroup', 
      'rowheader', 'scrollbar', 'search', 'searchbox', 'separator', 'slider', 
      'spinbutton', 'status', 'switch', 'tab', 'table', 'tablist', 'tabpanel', 
      'term', 'textbox', 'timer', 'toolbar', 'tooltip', 'tree', 'treegrid', 
      'treeitem'
    ];
    return validRoles.includes(role);
  }

  checkInputLabelPairs(form) {
    const inputs = form.querySelectorAll('input:not([type="hidden"]), select, textarea');
    const labels = form.querySelectorAll('label');
    
    let paired = 0;
    inputs.forEach(input => {
      const id = input.getAttribute('id');
      const hasLabel = labels.some(label => 
        label.getAttribute('for') === id || 
        label.contains(input)
      );
      const hasAriaLabel = input.hasAttribute('aria-label') || input.hasAttribute('aria-labelledby');
      
      if (hasLabel || hasAriaLabel) {
        paired++;
      }
    });

    return { paired, total: inputs.length };
  }

  checkReducedMotionCSS() {
    // Check if CSS contains reduced motion media query
    const styles = Array.from(document.styleSheets).map(sheet => {
      try {
        return Array.from(sheet.cssRules).map(rule => rule.cssText).join(' ');
      } catch (e) {
        return '';
      }
    }).join(' ');
    
    return styles.includes('@media (prefers-reduced-motion: reduce)') ||
           styles.includes('@media (prefers-reduced-motion:reduce)');
  }

  checkResponsiveCSS() {
    // Check for media queries
    const styles = Array.from(document.styleSheets).map(sheet => {
      try {
        return Array.from(sheet.cssRules).map(rule => rule.cssText).join(' ');
      } catch (e) {
        return '';
      }
    }).join(' ');
    
    return styles.includes('@media') && styles.includes('max-width');
  }

  testFocusTrap(modal) {
    const focusableElements = modal.querySelectorAll(
      'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    return {
      passed: focusableElements.length > 0,
      details: `${focusableElements.length} focusable elements in modal`
    };
  }

  getARIAPurpose(element) {
    const role = element.getAttribute('role');
    const ariaLabel = element.getAttribute('aria-label');
    const ariaLabelledby = element.getAttribute('aria-labelledby');
    
    return role || ariaLabel || ariaLabelledby || 'Unknown';
  }

  /**
   * Generate comprehensive accessibility report
   */
  generateReport() {
    console.log('\nðŸ“Š ACCESSIBILITY TEST RESULTS\n' + '='.repeat(50));
    
    // Summary
    const passedTests = this.results.filter(r => r.passed).length;
    const totalTests = this.results.length;
    
    console.log(`âœ… Passed: ${passedTests}/${totalTests} tests`);
    console.log(`âŒ Errors: ${this.errors.length}`);
    console.log(`âš ï¸ Warnings: ${this.warnings.length}`);
    console.log(`ðŸš« Violations: ${this.violations.length}`);
    
    // Detailed results
    console.log('\nðŸ“‹ DETAILED RESULTS:');
    this.results.forEach((result, index) => {
      const status = result.passed ? 'âœ…' : 'âŒ';
      console.log(`${status} ${result.test}: ${result.details}`);
    });
    
    // Issues
    if (this.errors.length > 0) {
      console.log('\nâŒ ERRORS:');
      this.errors.forEach(error => console.log(`â€¢ ${error}`));
    }
    
    if (this.warnings.length > 0) {
      console.log('\nâš ï¸ WARNINGS:');
      this.warnings.forEach(warning => console.log(`â€¢ ${warning}`));
    }
    
    if (this.violations.length > 0) {
      console.log('\nðŸš« VIOLATIONS:');
      this.violations.forEach(violation => console.log(`â€¢ ${violation}`));
    }
    
    // WCAG 2.1 AA Score
    const complianceScore = Math.round((passedTests / totalTests) * 100);
    console.log(`\nðŸŽ¯ WCAG 2.1 AA COMPLIANCE: ${complianceScore}%`);
    
    if (complianceScore >= 95) {
      console.log('ðŸ† Excellent! Meets WCAG 2.1 AA standards');
    } else if (complianceScore >= 80) {
      console.log('ðŸ‘ Good! Minor improvements needed');
    } else {
      console.log('âš ï¸ Needs improvement to meet WCAG 2.1 AA standards');
    }
    
    // Recommendations
    console.log('\nðŸ’¡ RECOMMENDATIONS:');
    if (this.errors.length > 0) {
      console.log('â€¢ Fix critical errors first to achieve basic accessibility');
    }
    if (this.warnings.length > 0) {
      console.log('â€¢ Address warnings to improve user experience');
    }
    if (complianceScore < 100) {
      console.log('â€¢ Consider running automated testing tools like axe-core or WAVE');
      console.log('â€¢ Test with actual assistive technologies (screen readers, keyboard only)');
      console.log('â€¢ Conduct user testing with people with disabilities');
    }
    
    // Save results
    this.saveResults();
  }

  saveResults() {
    const report = {
      timestamp: new Date().toISOString(),
      results: this.results,
      errors: this.errors,
      warnings: this.warnings,
      violations: this.violations,
      compliance: {
        score: Math.round((this.results.filter(r => r.passed).length / this.results.length) * 100),
        standard: 'WCAG 2.1 AA',
        passed: this.results.filter(r => r.passed).length,
        total: this.results.length
      }
    };
    
    // Log the report for now - in production, send to analytics/monitoring
    console.log('ðŸ“ˆ Accessibility Report:', report);
    
    // Store in localStorage for debugging
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('accessibilityReport', JSON.stringify(report, null, 2));
    }
  }
}

// Auto-run accessibility tests in development
if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        const tester = new AccessibilityTester();
        tester.runAllTests();
      }, 2000); // Wait 2 seconds for everything to load
    });
  } else {
    setTimeout(() => {
      const tester = new AccessibilityTester();
      tester.runAllTests();
    }, 2000);
  }
}

// Export for manual testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = AccessibilityTester;
}

// Make available globally for manual testing
window.AccessibilityTester = AccessibilityTester;